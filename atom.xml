<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dante-Game</title>
  <icon>https://www.gravatar.com/avatar/3d52e60c6199417f09d966057eded997</icon>
  <subtitle>致热爱游戏的人</subtitle>
  <link href="https://www.dante-game.com.cn/atom.xml" rel="self"/>
  
  <link href="https://www.dante-game.com.cn/"/>
  <updated>2022-10-26T13:21:46.023Z</updated>
  <id>https://www.dante-game.com.cn/</id>
  
  <author>
    <name>Dante</name>
    <email>a980735179@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面向对象编程的一些记录</title>
    <link href="https://www.dante-game.com.cn/2022/10/26/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95/"/>
    <id>https://www.dante-game.com.cn/2022/10/26/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95/</id>
    <published>2022-10-26T11:42:23.000Z</published>
    <updated>2022-10-26T13:21:46.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><p>说起面向对象, 大学老师总是很喜欢重复这个词, 但却总不喜欢把话说明白. 积累了一定的开发经验后, 我开始理解面向对象. 我们都知道面向对象的几个特性, 封装, 继承和多态, 有的可能还把抽象也算进去了. 但是为什么需要这些特性呢?</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="类的内存分布"><a href="#类的内存分布" class="headerlink" title="类的内存分布"></a>类的内存分布</h3><p>类中的数据可以简单的划分为成员变量和函数;<br>其中影响类实例化后对象大小的只有普通成员变量，虚函数，继承（单一继承，多重继承，重复继承，虚拟继承）</p><blockquote><p>因为虚函数和继承关系都会为类创建一张虚表, 并占用一个地址大小的变量进行存储</p></blockquote><p>而与类大小无关的因素：静态成员变量，静态成员函数及普通成员函数</p><blockquote><p>因为这些数据并不存储在栈空间或者堆空间上</p></blockquote><h3 id="类的内存对齐"><a href="#类的内存对齐" class="headerlink" title="类的内存对齐"></a>类的内存对齐</h3><p>类的大小并不是简单的变量大小之和, 类会以8个字节为单位进行内存对齐, 即数据的内存总是以8个字节为单位进行摆放,其中会有一些留空的空间, 而不是紧密排列的; 这是为了更高效的对数据进行寻址访问.</p><p>对上述简单的举例一下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">    virtual void print()&#123;cout&lt;&lt;&quot;hello world&quot;;&#125;</span><br><span class="line">    int a;</span><br><span class="line">    bool b;</span><br><span class="line">    int c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B&#123;</span><br><span class="line">    void print()&#123;cout&lt;&lt;&quot;hello world&quot;;&#125;</span><br><span class="line">    int a;</span><br><span class="line">    char b;</span><br><span class="line">    char c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>其中A实例化出的对象大小为<code>8(虚表)+ 4(int) + 1(bool) +3(内存对齐) + 4(int) + 4(内存对齐) = 24</code></p><p>其中B实例化出的对象大小为 <code>4(int) + 2(char) + 2(char) = 8</code></p><h3 id="private-protected-public"><a href="#private-protected-public" class="headerlink" title="private, protected, public"></a>private, protected, public</h3><p>先从这个讲起. 类中可以有不同访问权限的成员变量和函数, 我们用 <code>+</code> 表示public, 用 <code>-</code> 表示private, <code>#</code>表示protected;</p><blockquote><p>这里的符号是UML类图中的表示方法</p></blockquote><p>成员变量中,public是可供外界访问的;private只有类自己能访问; 而protected除了自己能访问以外,子类也能访问;</p><p>我们在继承的时候也能看见这三个词, 可以理解为限制访问的最高层级; 当子类继承父类时, 只能继承protected 和 public, 那么继承后他们的可见性如何呢? 继承时所规定的可见性即代表了最高可见性, 超过这个的会被降低为最高可见, 低于这个的不做处理, 可以简单的看一看下表</p><p><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/img2/20221026195243.png" alt=""></p><p>为什么有这些不同的可见性呢, 假如一个类的成员变量很多, 同时一个项目又在开展合作; 我们不希望一些关键的,或者外部用不着的东西也被访问到或被更改到, 于是有了不同的可见性, 这就是封装</p><h3 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h3><p>这里引入UML类图进行讲解</p><ul><li>UML的成员表示方法<ul><li>属性： <code>可见性 名称 ：类型 [ = 缺省值]</code></li><li>方法： <code>可见性 名称(参数列表) [ ： 返回类型]</code><br>如下:</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/img2/20221026204314.png" alt=""></p><p>接下来来了解一下类之间的关系</p><h4 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h4><p>最常见的关系,分为<strong>一般关联</strong>, <strong>聚合</strong> , <strong>组合</strong> 和 <strong>依赖</strong></p><ul><li>一般关联<br>某个类持有另一个类的变量,可以是单向的也可以是双向的,甚至可以指向自我</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/img2/20221026204658.png" alt=""></p><ul><li><p>聚合关系<br>一个对类的成员变量是一组另一个类, 之间构成整体与部分的关系, 且成员可以脱离整体独立存在<br><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/img2/20221026204852.png" alt=""></p></li><li><p>组合关系<br>是一种更强烈的聚合关系, 成员不能脱离整体存在<br><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/img2/20221026205843.png" alt=""></p></li><li><p>依赖关系<br>是一种低耦合的关联方式, 是临时性的<br><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/img2/20221026210036.png" alt=""></p></li><li><p>继承关系<br>是一种高耦合的关联方式, 即泛化关系<br><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/img2/20221026210256.png" alt=""></p></li><li><p>实现关系<br>是接口与实现类之间的关系<br><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/img2/20221026210343.png" alt=""></p></li></ul><h2 id="面向对象的基本原则"><a href="#面向对象的基本原则" class="headerlink" title="面向对象的基本原则"></a>面向对象的基本原则</h2><ul><li><p>单一职责原则（Single Responsibility Principle）<br>每一个类应该专注于做一件事情。</p></li><li><p>里氏替换原则（Liskov Substitution Principle）<br>超类存在的地方，子类是可以替换的。</p></li><li><p>依赖倒置原则（Dependence Inversion Principle）</p></li></ul><p>实现尽量依赖抽象，不依赖具体实现。</p><ul><li>接口隔离原则（Interface Segregation Principle）</li></ul><p>应当为客户端提供尽可能小的单独的接口，而不是提供大的总的接口。</p><ul><li>迪米特法则（Law Of Demeter）</li></ul><p>又叫最少知识原则，一个软件实体应当尽可能少的与其他实体发生相互作用。</p><ul><li>开闭原则（Open Close Principle）</li></ul><p>面向扩展开放，面向修改关闭。</p><ul><li>组合/聚合复用原则（Composite/Aggregate Reuse Principle CARP）</li></ul><p>尽量使用合成/聚合达到复用，尽量少用继承。原则： 一个类中有另一个类的对象。</p><blockquote><p>具体细则请参考<a href="https://blog.csdn.net/guanmao4322/article/details/85947083">链接</a></p></blockquote><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul><li>内聚度<br>内聚度是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好只做一件事，高内聚就是一个类封装的很完善，每个类只完成一项任务，也就是常说的单一责任原则。</li><li>耦合度<br>耦合度是对模块间关联程度的度量，模块间的耦合度是指模块之间的依赖关系，包括控制关系、调用关系、数据传递关系，模块间联系越多，耦合性越强，模块的独立性越差。</li></ul><p>我们在开发之前总会对项目框架的构成进行设计, 其中最基础的就是类图的设计, 我们需要处理各个类的功能的同时合理安排类之间的关系, 以实现<strong>高内聚 低耦合</strong>的程序架构,即符合面向对象的基本原则, 这样的程序具有优秀的扩展性和可维护性, 同时也为合作带来便利.</p><p>本着这样的设计理念,有了各种各样的设计模式来辅助我们的系统更合理的架构.</p><h2 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h2><p><a href="https://blog.csdn.net/weixin_57504000/article/details/124218420">https://blog.csdn.net/weixin_57504000/article/details/124218420</a><br><a href="https://blog.csdn.net/guanmao4322/article/details/85947083">https://blog.csdn.net/guanmao4322/article/details/85947083</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;面向对象编程&quot;&gt;&lt;a href=&quot;#面向对象编程&quot; class=&quot;headerlink&quot; title=&quot;面向对象编程&quot;&gt;&lt;/a&gt;面向对象编程&lt;/h1&gt;&lt;p&gt;说起面向对象, 大学老师总是很喜欢重复这个词, 但却总不喜欢把话说明白. 积累了一定的开发经验后, 我开始理</summary>
      
    
    
    
    <category term="基础" scheme="https://www.dante-game.com.cn/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="学习" scheme="https://www.dante-game.com.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="记录" scheme="https://www.dante-game.com.cn/tags/%E8%AE%B0%E5%BD%95/"/>
    
    <category term="经验" scheme="https://www.dante-game.com.cn/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>GameJam开发复盘</title>
    <link href="https://www.dante-game.com.cn/2022/10/24/GameJam%E5%BC%80%E5%8F%91%E5%A4%8D%E7%9B%98/"/>
    <id>https://www.dante-game.com.cn/2022/10/24/GameJam%E5%BC%80%E5%8F%91%E5%A4%8D%E7%9B%98/</id>
    <published>2022-10-24T05:45:55.000Z</published>
    <updated>2022-10-26T11:40:22.782Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GameJam开发作品-四季复盘"><a href="#GameJam开发作品-四季复盘" class="headerlink" title="GameJam开发作品 四季复盘"></a>GameJam开发作品 四季复盘</h1><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="项目视频"><a href="#项目视频" class="headerlink" title="项目视频"></a>项目视频</h3><p><a href="https://www.bilibili.com/video/BV1JK411D7fo?share_source=copy_web&amp;vd_source=da8280c5c3d89248027ccac72e16e11e"><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/img2/20221024143414.png" alt=""></a></p><p>故事的主人翁是一名树芽, 他出生在一颗绿茵环绕的大树下。在游戏中树芽开始了他的旅途，旅行的过程中他经历春夏秋冬, 一边净化环境一边旅行。虽然旅途中充满危险，但生命是一代又一代生生不息的，在不断生长-进化-凋零-化种的循环中，玩家需要通过决策安排路径来绿化环境创造可行进路线。在这场旅途的最后树芽也化作了一颗大树。</p><h3 id="玩法设计"><a href="#玩法设计" class="headerlink" title="玩法设计"></a>玩法设计</h3><p><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/img2/20221024144218.png" alt=""></p><p>地图是以方块构成的网格结构, 角色可以上下左右在一格高度差内移动, 从出生点移动到达终点完成闯关</p><p>角色拥有生命值和生命数, 玩家经过被污染的方块时生命值减少并且净化方块; 经过被净化的方块不消耗生命;</p><p><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/img2/20221024144326.png" alt=""></p><p>当生命耗尽时会在原地死亡并且选择死亡的方式来改变地图: 如将地图向上扩充一格, 将地图向前扩充一格, 破坏当前方块等</p><p>玩家需要规划路线选择死亡地点与死亡方式来通关</p><h2 id="开发日志"><a href="#开发日志" class="headerlink" title="开发日志"></a>开发日志</h2><p>因为大家都缺少gamejam经验与项目经验, 这个作品可以说几乎是从零开始制作, 从零开始开发的作品. 同样也是个人真正完成了的第一个游戏, 所以特此记录并复盘.</p><h3 id="主题发散与思考"><a href="#主题发散与思考" class="headerlink" title="主题发散与思考"></a>主题发散与思考</h3><p>10月14日发布主题 End where you started<br>通过共享文档讨论主题所引申出的想法, 讨论了主题方向 ,故事背景, 核心玩法<br>最终方向固定在 回溯, 溯源, 循环等;</p><p>然后觉得四季这个主题不错, 又有人提到了可以通过越来越恶劣的环境来映射环境污染;已经结合确定了溯源的大方向, 在玩法上选择了类似肉鸽的玩法, 但是和肉鸽不同, 玩家的死亡是有限的, 同时死亡也能对场景进行改变; 映射了主题End where you started.</p><p><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/img2/20221025160517.png" alt=""></p><p>最终决定了初版的设计思路如下<br><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/img2/20221025160948.png" alt=""></p><h3 id="需求指定与分工安排"><a href="#需求指定与分工安排" class="headerlink" title="需求指定与分工安排"></a>需求指定与分工安排</h3><p>在完善了故事背景与玩法后, 就开始分工开发, 由2位美术讨论风格设计场景与角色, 程序分别开发UI与Gameplay内容, 各部分同步进行开发, 美术的风格需求由负责技术美术板块的我尽力实现</p><p>在整理游戏流程图后 确保每位成员了解项目的预期内容<br>随后在第二天上午前制定了详细的安排(因为内容太多实在放不下, <a href="https://kdocs.cn/l/cguAuZlqpFKP">点击链接查看详细内容</a>)<br><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/img2/20221025161654.png" alt=""></p><h3 id="设计与开发"><a href="#设计与开发" class="headerlink" title="设计与开发"></a>设计与开发</h3><p><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/img2/20221025174000.png" alt=""></p><blockquote><p>则张图是早期的设计,现在看上去很蠢</p></blockquote><p>开发主要围绕着关卡, 方块, 角色, UI等进行<br>主要采用了单例模式的基类和基于观察者模式的事件系统, 以单关卡为例进行开发</p><p>前期采用二维数组对关卡中的<strong>方块</strong>进行绑定与访问(这个设计是很不好的), 在场景初始化时, 关卡单例会获取场景中所有的方块并排列为二维数组,二维数组的方块会沿上下左右4个方向判断可行进路线加入List以实现方块与方块间的连接, 同时方块记录着方块的信息来判定是否可交互是否可对玩家造成伤害等</p><p><strong>关卡单例除</strong>了记录了关卡信息,方块组信息,还提供A*寻路算法, 因为unity中没有优先队列所以在网上扒了一个优先队列基类进行开发, 这期间因为bug耽搁了不少时间.</p><p>关卡与方块的游戏逻辑编写完后, 开始着手开发<strong>角色</strong>逻辑. 由于玩家的移动高度受限所以逻辑比较简单, 每次鼠标选择寻路终点后玩家会从关卡类的完成寻路运算的path中获取第一个方块的信息作为nextCube, 玩家的运动逻辑就是当nextCube和玩家当前的currentCube不同时尝试移动到下一个方块.并加上逻辑的判断以满足游戏性</p><p><strong>游戏交互</strong>, 游戏交互主要是通过鼠标与摄像机进行交互的,<br>在鼠标上,我们希望鼠标触碰到方块能够让方块触发抬起的动画, 寻路中我们希望待行进的方块同样抬起并拥有特效, 为此我们为每个方块添加了cubeAction组件来表示交互;<br>摄像机上,我们对每个场景设置了4个方向的虚拟相机通过旋转数组控制相机的激活与关闭, 这一点在后续的选关界面也是同样的思路</p><p><strong>UI</strong>方面完成了开始界面,游戏内界面的ui显示和退出暂停重开等功能</p><p><strong>渲染</strong>方面, 采用urp实现了基本的后处理, 采用sobel算子基于深度法线进行外描边, 同时使用mask来对需要描边和不需要描边的部分进行划分;<br>草的部分想要实现毛茸茸的效果, 所以借助了之前用于外描边的mask, 将其互斥的部分进行径向模糊以伪造草毛茸茸的效果,在低模无贴图的情况下效果还不错(但是后续可能就不是那么合适了,但也没时间调整了)<br><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/img2/径向模糊草.gif" alt=""></p><p>涉及到单对多的关系时,我们采用事件系统来传递信息; 多对单,单对单采用单例.</p><p>实现了基本的GamePlay内容逻辑后游戏已经能玩了<br><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/img2/关卡演示.gif" alt=""></p><h3 id="工作内容对接"><a href="#工作内容对接" class="headerlink" title="工作内容对接"></a>工作内容对接</h3><h4 id="关卡管理器"><a href="#关卡管理器" class="headerlink" title="关卡管理器"></a>关卡管理器</h4><p>前面的工作都是基于单关卡的,但是为了扩增关卡,还需要设计一个关卡管理器, 他拥有切换场景, 配置关卡基本信息, 返回菜单, 与选关等功能<br>由于之前没怎么接触过多场景开发,还采用的是同步场景加载; 在负责UI的程序的提醒下改用了异步加载, 并且对于场景加载与卸载加入了更多的逻辑, 比如玩家的安装与卸载, 通过事件控制UI等</p><h4 id="游戏内UI的对接"><a href="#游戏内UI的对接" class="headerlink" title="游戏内UI的对接"></a>游戏内UI的对接</h4><p>因为游戏中的UI一部分需要高频率的更新, 一部分又直接影响着整个游戏的流程, 比如玩家死后需要选择功能, 只有选择了功能才能复活; 在这一部分因为之前写代码没有考虑这么多, 所以大改了底层逻辑, 并且整理出一张事件表来通知各个部分.<br>在这个过程中bug相当多, 原逻辑的bug层出不穷, 仿佛以前运行的场景是靠bug支持下去的</p><h3 id="美术部分的对接"><a href="#美术部分的对接" class="headerlink" title="美术部分的对接"></a>美术部分的对接</h3><p>这一部分其实因为没有经验和沟通不足浪费了很多时间<br>美术部分的对接因为采用的是预制体,所以会轻松很多, 但是也出现了事前沟通不足的问题, 比如美术所提供的资源是一整个场景, 而不是单个的prefab, 后续制作的prefab初始数值有问题,导致无法reset等; 因为模型着色需求简单, 所以美术使用的是单个材质球, 这也导致后续shader对接上出现了问题, 但在沟通后更改为了贴图.</p><p>然后大家选取了字体并设计了UI, 整个游戏的雏形似乎就这么做好了</p><h3 id="关卡部分"><a href="#关卡部分" class="headerlink" title="关卡部分"></a>关卡部分</h3><h4 id="关卡设计"><a href="#关卡设计" class="headerlink" title="关卡设计"></a>关卡设计</h4><p>因为关卡是网格性的多状态关卡, 所以使用excel制作了带图例的网格, 可以通过复制粘贴来快速构建关卡(这一部分因为没时间开发文件读取, 所以需要开发者手动按照图摆放关卡)<br><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/img2/20221025174231.png" alt=""></p><p>在做完上述内容的时候似乎大家都觉得做的差不多了, 但这时也暴露出没有转职策划的团队的问题. 没有人设计关卡, 程序忙于优化完善逻辑修复bug, 美术忙于各自的内容. 没有人设计关卡, 导致最终结果的关卡设计不尽如人意</p><p>关卡以春夏秋冬交替进行, 一共设计了12个关卡和2个相同的初始与结束关卡用于切题<br>因为春夏秋冬所使用的模型贴图各不相同, 所以制作了4个场景模板, 所有场景都基于这4个模板进行更改.<br>但这个做法其实是很不恰当的, 与其使用模板更应该在代码层面就将春夏秋冬不同表现进行实现;采用这样的方式的问题很快就出现了, 我设计的关卡的顺序需要调整, 意味着季节需要变化, 同时意味着之前摆放好的关卡白摆了</p><h4 id="关卡开发"><a href="#关卡开发" class="headerlink" title="关卡开发"></a>关卡开发</h4><p>因为在最初的预想中, 我们是希望关卡内是拥有特殊的触发器来使各种关卡有不同的表现形式, 比如定期传播污染的方块, 走过后会消失的方块, 不可破坏的方块, 类似机关能改变场景的方块, 触碰后能回复生命的道具等 一些简单实现的东西. 但由于堆积到了最后, 不得不面临同时处理bug, 一边摆放关卡一边开发功能一边测试功能的窘境</p><h3 id="后期的调整"><a href="#后期的调整" class="headerlink" title="后期的调整"></a>后期的调整</h3><p>在完成上述内容后游戏基本已经满足提交条件了, 也已经录制了视频; 但在关卡设计的过程中我们发现, 基于二维数组的关卡基础设计何难实现竖直空间上的游戏玩法, 即一个二维坐标只能拥有一个高度的方块; 在商讨后我们连夜更改了底层设计</p><p>从原有的二维数组绑定方块关系, 改为了通过射线检测绑定. 每个方块会从当前高度以及上下高度差为1的位置向前后左右4个方向发射射线, 一共12条射线对周围的方块进行绑定.  其中考虑到了可能会因为方块重叠,斜交等产生的非法路径处理.</p><p>同时大量更改了原有的代码, 结果带来的是更轻便的代码结构, 更方便的关卡摆放.对此也是很满意的.虽然付诸了大量的时间更改代码调试bug</p><h2 id="需要思考的问题"><a href="#需要思考的问题" class="headerlink" title="需要思考的问题"></a>需要思考的问题</h2><ul><li>什么时候用单例什么时候用观察者<br>  尽可能少的适用单例<br>  全局的数据会破坏代码的封装性, 要尽可能的少用, 如非必要情况尽可能不要使用</li><li>篡改底层数据<br>单个对象尽可能只改变自己的数据, 通过观察者模式来与其他对象进行交互</li><li>为什么要用空接口<br>  提供标识</li><li>同步加载与异步加载的适用场景<br>  同步加载会将所有的线程用于加载场景, 意味着期间会产生卡顿, 但是可以直接拿到加载的返回值, 适用于少量重要物体的加载<br>  异步加载速度慢, 但能够让游戏正常运行, 适用于大量物体的加载</li><li>resource和asset bundle的区别和使用场景</li><li>什么时候会触发GC,如何减少GC</li><li>面向对象的几个基本原则<ul><li>单一职责原则</li><li>里氏替换原则</li><li>依赖倒置原则</li><li>接口隔离原则</li><li>迪米特法则</li><li>开闭原则</li><li>组合/聚合复用原则</li></ul></li></ul><h2 id="总结与展望"><a href="#总结与展望" class="headerlink" title="总结与展望"></a>总结与展望</h2><p>虽然说本次项目充斥着各种不规范,但是从这些不规范中我算是体会到了为什么大家希望规范的代码.</p><p>在整个项目过程中充分感受到了各种设计模式所带来的便利, 也从各种bug中学习到了为什么面向对象的开发如此强调开闭原则.在建立游戏框架时考虑到扩展的问题不仅会加快开发的速度也会提升后期的可维护性.<br>在本次项目还可提升的部分有很多, 比如将游戏信息进一步封装并支持文件读取, 基于input system适配各种输入, 项目的资源管理, 对于内存的管理应该建立一个缓存池减少gc所带来的性能开销, 多个重复对象的场景可以考虑采用ECS架构来提升高速缓存命中率等.<br>还要学习的地方还有很多, 十分有幸参与本次gamejam;</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;GameJam开发作品-四季复盘&quot;&gt;&lt;a href=&quot;#GameJam开发作品-四季复盘&quot; class=&quot;headerlink&quot; title=&quot;GameJam开发作品 四季复盘&quot;&gt;&lt;/a&gt;GameJam开发作品 四季复盘&lt;/h1&gt;</summary>
    
    
    
    <category term="Unity" scheme="https://www.dante-game.com.cn/categories/Unity/"/>
    
    
    <category term="学习" scheme="https://www.dante-game.com.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="记录" scheme="https://www.dante-game.com.cn/tags/%E8%AE%B0%E5%BD%95/"/>
    
    <category term="经验" scheme="https://www.dante-game.com.cn/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="计算机图形学" scheme="https://www.dante-game.com.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="游戏引擎" scheme="https://www.dante-game.com.cn/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="Unity" scheme="https://www.dante-game.com.cn/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity资源加载与优化</title>
    <link href="https://www.dante-game.com.cn/2022/09/30/Unity%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
    <id>https://www.dante-game.com.cn/2022/09/30/Unity%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E4%B8%8E%E4%BC%98%E5%8C%96/</id>
    <published>2022-09-30T08:07:26.000Z</published>
    <updated>2022-09-30T13:41:10.692Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unity-资源加载与优化"><a href="#Unity-资源加载与优化" class="headerlink" title="Unity 资源加载与优化"></a>Unity 资源加载与优化</h1><h2 id="游戏对象与资源的关系"><a href="#游戏对象与资源的关系" class="headerlink" title="游戏对象与资源的关系"></a>游戏对象与资源的关系</h2><h3 id="资源和对象的创建"><a href="#资源和对象的创建" class="headerlink" title="资源和对象的创建"></a>资源和对象的创建</h3><h3 id="资源和对象的卸载"><a href="#资源和对象的卸载" class="headerlink" title="资源和对象的卸载"></a>资源和对象的卸载</h3><h3 id="C-的GC"><a href="#C-的GC" class="headerlink" title="C#的GC"></a>C#的GC</h3><h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><h2 id="Resources-与-AssetBundle"><a href="#Resources-与-AssetBundle" class="headerlink" title="Resources 与 AssetBundle"></a>Resources 与 AssetBundle</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Unity-资源加载与优化&quot;&gt;&lt;a href=&quot;#Unity-资源加载与优化&quot; class=&quot;headerlink&quot; title=&quot;Unity 资源加载与优化&quot;&gt;&lt;/a&gt;Unity 资源加载与优化&lt;/h1&gt;&lt;h2 id=&quot;游戏对象与资源的关系&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="Unity" scheme="https://www.dante-game.com.cn/categories/Unity/"/>
    
    
    <category term="学习" scheme="https://www.dante-game.com.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="记录" scheme="https://www.dante-game.com.cn/tags/%E8%AE%B0%E5%BD%95/"/>
    
    <category term="经验" scheme="https://www.dante-game.com.cn/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="游戏引擎" scheme="https://www.dante-game.com.cn/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="Unity" scheme="https://www.dante-game.com.cn/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>urp概述</title>
    <link href="https://www.dante-game.com.cn/2022/09/29/urp%E6%A6%82%E8%BF%B0/"/>
    <id>https://www.dante-game.com.cn/2022/09/29/urp%E6%A6%82%E8%BF%B0/</id>
    <published>2022-09-29T10:27:48.000Z</published>
    <updated>2022-10-25T10:05:05.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="URP概述"><a href="#URP概述" class="headerlink" title="URP概述"></a>URP概述</h1><h2 id="关于URP的架构"><a href="#关于URP的架构" class="headerlink" title="关于URP的架构"></a>关于URP的架构</h2><p>在使用URP之前,我们最好能够知道以下几个名词具体是什么,他们之间的关系是怎样的</p><ul><li>RenderPipelineAsset</li><li>RenderPipeline</li><li>Renderer</li><li>RenderPass</li><li>RenderFeature</li><li>CommandBuffer</li><li>RenderTarget<h3 id="SRP—脚本渲染管线"><a href="#SRP—脚本渲染管线" class="headerlink" title="SRP—脚本渲染管线"></a>SRP—脚本渲染管线</h3><strong><font color = red>RenderPipelineAsset</font></strong> 是用于生成RenderPipeline的资源文件,创建好的RenderPipeline可以在项目设置-&gt;图形中进行配置,配置完成后项目就不再使用内置渲染管线,而是使用由RenderPipeline所定义的渲染管线,下面是一个简单的 <strong><font color = red>RenderPipeline</font></strong> ,其定义了画面该以怎样的顺序以及怎样的方式进行渲染<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class SampleRenderPipeline : RenderPipeline&#123;</span><br><span class="line">    protected override void Render(ScriptableRenderContext context, Camera[] cameras)&#123;</span><br><span class="line">        foreach (var camera in cameras)&#123;</span><br><span class="line">            context.SetupCameraProperties(camera);</span><br><span class="line">            camera.TryGetCullingParameters(out var parameters);</span><br><span class="line">            var results = context.Cull(ref parameters);</span><br><span class="line">            </span><br><span class="line">            //绘制不透明物体</span><br><span class="line">            DrawingSettings ds = new DrawingSettings();</span><br><span class="line">            ds.SetShaderPassName(0, new ShaderTagId(&quot;SRPSample1&quot;));</span><br><span class="line">            ds.sortingSettings = new SortingSettings()&#123;criteria = SortingCriteria.CommonOpaque&#125;;</span><br><span class="line">            FilteringSettings fs = new FilteringSettings(RenderQueueRange.opaque);</span><br><span class="line">            context.DrawRenderers(results, ref ds, ref fs);</span><br><span class="line">            </span><br><span class="line">            //绘制天空盒</span><br><span class="line">            context.DrawSkybox(camera);</span><br><span class="line"></span><br><span class="line">            //绘制透明物体</span><br><span class="line">            ds = new DrawingSettings();</span><br><span class="line">            ds.SetShaderPassName(0, new ShaderTagId(&quot;SRPSample1&quot;));</span><br><span class="line">            ds.sortingSettings = new SortingSettings()&#123;criteria = SortingCriteria.CommonTransparent&#125;;</span><br><span class="line">            fs = new FilteringSettings(RenderQueueRange.transparent);</span><br><span class="line">            context.DrawRenderers(results, ref ds, ref fs);</span><br><span class="line">        &#125;</span><br><span class="line">        // 将所有缓冲的指令提交。指令被提交到引擎，引擎再将指令提交到图形驱动</span><br><span class="line">        context.Submit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Universal-RenderPipeline—通用渲染管线"><a href="#Universal-RenderPipeline—通用渲染管线" class="headerlink" title="Universal RenderPipeline—通用渲染管线"></a>Universal RenderPipeline—通用渲染管线</h3>可以看出SRP用于绘制画面并提交到CPU,代码中分别对不透明物体,天空盒,透明物体进行了绘制,但可以看出代码重复率很高,如果需要绘制的物体复杂起来可读性就会很差,所以在<strong>Universal-RenderPipeline</strong>中把这些绘制方面的事情抽象成了<strong>RenderPass</strong>,RenderPipeline只需要调用不同RenderPass中的<strong>Execute</strong>方法就能完成画面的绘制<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class SampleRenderPipeline : RenderPipeline&#123;</span><br><span class="line">    List&lt;ScriptableRenderPass&gt; m_ActiveRenderPassQueue;</span><br><span class="line"></span><br><span class="line">    DrawObjectsPass m_RenderOpaqueForwardPass;</span><br><span class="line">    DrawSkyboxPass m_DrawSkyboxPass;</span><br><span class="line">    DrawObjectsPass m_RenderTransparentForwardPass;</span><br><span class="line"></span><br><span class="line">    public SampleRenderPipeline()&#123;</span><br><span class="line">        m_ActiveRenderPassQueue = new List&lt;ScriptableRenderPass&gt;(32);</span><br><span class="line"></span><br><span class="line">        m_RenderOpaqueForwardPass = new DrawObjectsPass(true);</span><br><span class="line">        m_DrawSkyboxPass = new DrawSkyboxPass();</span><br><span class="line">        m_RenderTransparentForwardPass = new DrawObjectsPass(false);</span><br><span class="line">    </span><br><span class="line">        m_ActiveRenderPassQueue.Add(m_RenderOpaqueForwardPass); </span><br><span class="line">        m_ActiveRenderPassQueue.Add(m_DrawSkyboxPass); </span><br><span class="line">        m_ActiveRenderPassQueue.Add(m_RenderTransparentForwardPass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected override void Render(ScriptableRenderContext context, Camera[] cameras)&#123;</span><br><span class="line">        foreach (var camera in cameras)&#123;</span><br><span class="line">            context.SetupCameraProperties(camera);</span><br><span class="line">            camera.TryGetCullingParameters(out var parameters);</span><br><span class="line">            var results = context.Cull(ref parameters);</span><br><span class="line">            </span><br><span class="line">            RenderingData renderingData = new RenderingData() &#123; cullResults = results, cameraData = camera&#125;;</span><br><span class="line"></span><br><span class="line">            foreach (var renderPass in m_ActiveRenderPassQueue)&#123;</span><br><span class="line">                renderPass.Execute(context, renderingData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        context.Submit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RenderPass—渲染通道"><a href="#RenderPass—渲染通道" class="headerlink" title="RenderPass—渲染通道"></a>RenderPass—渲染通道</h3><strong><font color = red>RenderPass(渲染通道)</font></strong> 是一个物体经过整个渲染管线后的结果,我们的画面最终结果是由一个有一个的通道叠加而成的.在内置管线的Shader中,一个SubShader中可以有多个Pass,因此我们可以绘制如阴影,外发光等多种效果,而在Universal RP中,一个SubShader只能有一个Pass,额外的Pass需要由RenderFeature进行实现.</li></ul><p>我们可以看一看简单的RenderPass的结构<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class DrawObjectsPass : ScriptableRenderPass&#123;</span><br><span class="line">    bool bOpaque;</span><br><span class="line">    public DrawObjectsPass (bool isOpaque)&#123;</span><br><span class="line">        bOpaque = isOpaque;</span><br><span class="line">    &#125;</span><br><span class="line">    public override void Execute(ScriptableRenderContext context, RenderingData renderingData)&#123;</span><br><span class="line">            DrawingSettings ds = new DrawingSettings();</span><br><span class="line">            ds.SetShaderPassName(0, new ShaderTagId(&quot;SRPSample1&quot;));</span><br><span class="line">            ds.sortingSettings = new SortingSettings()&#123;criteria = bOpaque ? SortingCriteria.CommonOpaque : SortingCriteria.CommonTransparent&#125;;</span><br><span class="line">            FilteringSettings fs = new FilteringSettings(bOpaque ? RenderQueueRange.opaque : RenderQueueRange.transparent);</span><br><span class="line">            context.DrawRenderers(renderingData.cullResults, ref ds, ref fs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Renderer—渲染器"><a href="#Renderer—渲染器" class="headerlink" title="Renderer—渲染器"></a>Renderer—渲染器</h3><p>因为RenderPass有很多,为了更方便的添加和管理Pass,在RenderPipeline与RenderPass之间抽象出了一层Renderer<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ScriptableRenderer&#123;</span><br><span class="line">    List&lt;ScriptableRenderPass&gt; m_ActiveRenderPassQueue = new List&lt;ScriptableRenderPass&gt;(32);</span><br><span class="line"></span><br><span class="line">    public void EnqueuePass(ScriptableRenderPass pass)&#123;</span><br><span class="line">        m_ActiveRenderPassQueue.Add(pass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void Setup(ScriptableRenderContext context, ref RenderingData renderingData);</span><br><span class="line"></span><br><span class="line">    public void Clear()&#123;</span><br><span class="line">        m_ActiveRenderPassQueue.Clear();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void Execute(ScriptableRenderContext context, RenderingData renderingData)&#123;</span><br><span class="line">        foreach (var renderPass in m_ActiveRenderPassQueue)&#123;</span><br><span class="line">            renderPass.Execute(context, renderingData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Renderer的实现如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class ForwardRenderer : ScriptableRenderer&#123;</span><br><span class="line">    DrawObjectsPass m_RenderOpaqueForwardPass;</span><br><span class="line">    DrawSkyboxPass m_DrawSkyboxPass;</span><br><span class="line">    DrawObjectsPass m_RenderTransparentForwardPass;</span><br><span class="line">    </span><br><span class="line">    public ForwardRenderer()&#123;</span><br><span class="line">        m_RenderOpaqueForwardPass = new DrawObjectsPass(true);</span><br><span class="line">        m_DrawSkyboxPass = new DrawSkyboxPass();</span><br><span class="line">        m_RenderTransparentForwardPass = new DrawObjectsPass(false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public override void Setup(ScriptableRenderContext context, ref RenderingData renderingData)&#123;</span><br><span class="line">        EnqueuePass(m_RenderOpaqueForwardPass); </span><br><span class="line">        EnqueuePass(m_DrawSkyboxPass); </span><br><span class="line">        EnqueuePass(m_RenderTransparentForwardPass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>增加了Renderer的RenderPipeline现在如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class SampleRenderPipeline : RenderPipeline&#123;</span><br><span class="line">    ForwardRenderer m_ForwardRenderer;</span><br><span class="line">    public SampleRenderPipeline()&#123;</span><br><span class="line">        m_ForwardRenderer = new ForwardRenderer();</span><br><span class="line">    &#125;</span><br><span class="line">    protected override void Render(ScriptableRenderContext context, Camera[] cameras)&#123;</span><br><span class="line">        foreach (var camera in cameras)&#123;</span><br><span class="line">            context.SetupCameraProperties(camera);</span><br><span class="line">            camera.TryGetCullingParameters(out var parameters);</span><br><span class="line">            var results = context.Cull(ref parameters);</span><br><span class="line"></span><br><span class="line">            RenderingData renderingData = new RenderingData() &#123; cullResults = results, cameraData = camera&#125;;</span><br><span class="line">            </span><br><span class="line">            m_ForwardRenderer.Clear();</span><br><span class="line">            m_ForwardRenderer.Setup(context, ref renderingData); </span><br><span class="line">            m_ForwardRenderer.Execute(context, renderingData);</span><br><span class="line">        &#125;</span><br><span class="line">        context.Submit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>实现的Renderer是ForwardRenderer(前向渲染器),意味着通过Renderer我们除了可以对Pass进行管理以外还能对不同的渲染方式进行控制,如延迟渲染,自定义渲染等</p><h3 id="RenderFeature"><a href="#RenderFeature" class="headerlink" title="RenderFeature"></a>RenderFeature</h3><p>在固定的Renderer流程中,我们可以通过 <strong><font color = red>Render Feature</font></strong> 来动态的添加新的pass来实现各种效果<br>RenderFeature结构如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class LensFlareRendererFeature : ScriptableRendererFeature</span><br><span class="line">&#123;</span><br><span class="line">    class LensFlarePass : ScriptableRenderPass&#123;</span><br><span class="line">        public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData)&#123;</span><br><span class="line">            Debug.Log(message: &quot;The Execute() method runs.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private LensFlarePass _lensFlarePass;</span><br><span class="line">    public override void Create()&#123;</span><br><span class="line">        _lensFlarePass = new LensFlarePass();</span><br><span class="line">    &#125;</span><br><span class="line">    public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData)&#123;</span><br><span class="line">        renderer.EnqueuePass(_lensFlarePass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>RenderFeature具有实例化pass并将其添加到渲染队列中的功能,可以通过控制开关来动态的添加pass,而功能的实现主要依赖RenderPass </p><h3 id="RenderContext—渲染上下文"><a href="#RenderContext—渲染上下文" class="headerlink" title="RenderContext—渲染上下文"></a>RenderContext—渲染上下文</h3><p>渲染上下文是在之前的代码中重复出现的一个参数, <strong>RenderContext</strong> 负责调度和提交渲染状态的更新以及绘制指令到GPU。</p><h3 id="RenderStateBlock—渲染状态更新"><a href="#RenderStateBlock—渲染状态更新" class="headerlink" title="RenderStateBlock—渲染状态更新"></a>RenderStateBlock—渲染状态更新</h3><p>RenderContext能够更新渲染状态<br>其中最主要的更新指令为:<code>context.DrawRenderers(renderingData.cullResults, ref drawingSettings, ref m_FilteringSettings, ref m_RenderStateBlock)</code></p><ul><li>CullingResult是记录对物体，灯光，反射探针进行剔除的结果</li><li>DrawingSetting设置绘制顺序以及绘制时使用哪一个Shader中的Pass。</li><li>FilteringSetting设置过滤设置渲染指定的Layer，RenderStateBlock更改(StateBlock)来重载深度、模板写入方式。</li></ul><h3 id="CommandBuffer"><a href="#CommandBuffer" class="headerlink" title="CommandBuffer"></a>CommandBuffer</h3><p><strong><font color = red>Command Buffer</font></strong> 保存着渲染命令列表，如(set render target, draw mesh等等)，可以设置为在摄像机渲染期间的不同点执行。RenderContext会提交存储在该列表的渲染命令以达成用户需求的效果</p><p><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub@master/img2/20221004194459.png" alt=""><br>这些渲染命令是RenderPass能够实现各种效果的关键,比如,我们可以声明一个带有shader的材质,通过Command Buffer可以将材质应用到对应的layer中,我们可以看一看官方示例所实现的镜头光晕<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class LensFlareRendererFeature : ScriptableRendererFeature</span><br><span class="line">&#123;</span><br><span class="line">    class LensFlarePass : ScriptableRenderPass&#123;</span><br><span class="line">        private Material _material;</span><br><span class="line">        private Mesh _mesh;</span><br><span class="line"></span><br><span class="line">        public LensFlarePass(Material material, Mesh mesh)&#123;</span><br><span class="line">            _material = material;</span><br><span class="line">            _mesh = mesh;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public override void Execute(ScriptableRenderContext context,</span><br><span class="line">            ref RenderingData renderingData)&#123;</span><br><span class="line">            CommandBuffer cmd = CommandBufferPool.Get(name: &quot;LensFlarePass&quot;);</span><br><span class="line">            Camera camera = renderingData.cameraData.camera;</span><br><span class="line">            cmd.SetViewProjectionMatrices(Matrix4x4.identity, Matrix4x4.identity);</span><br><span class="line">            Vector3 scale = new Vector3(1, camera.aspect, 1);</span><br><span class="line"></span><br><span class="line">            foreach (VisibleLight visibleLight in renderingData.lightData.visibleLights)&#123;</span><br><span class="line">                Light light = visibleLight.light;</span><br><span class="line">                Vector3 position = camera.WorldToViewportPoint(light.transform.position) * 2 - Vector3.one;</span><br><span class="line">                position.z = 0;</span><br><span class="line">                cmd.DrawMesh(_mesh, Matrix4x4.TRS(position, Quaternion.identity, scale),_material, 0, 0);</span><br><span class="line">            &#125;</span><br><span class="line">            context.ExecuteCommandBuffer(cmd);</span><br><span class="line">            CommandBufferPool.Release(cmd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private LensFlarePass _lensFlarePass;</span><br><span class="line">    public Material material;</span><br><span class="line">    public Mesh mesh;</span><br><span class="line">    public override void Create()&#123;</span><br><span class="line">        _lensFlarePass = new LensFlarePass(material, mesh);</span><br><span class="line">        _lensFlarePass.renderPassEvent = RenderPassEvent.AfterRenderingSkybox;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData)&#123;</span><br><span class="line">        if (material != null &amp;&amp; mesh != null)&#123;</span><br><span class="line">            renderer.EnqueuePass(_lensFlarePass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="RenderTarget"><a href="#RenderTarget" class="headerlink" title="RenderTarget"></a>RenderTarget</h3><p>在3D计算机图形领域，RenderTarget是现代图形处理单元(gpu)的一个特性，它允许3D场景被渲染到一个中间内存缓冲区，或渲染目标纹理(RTT)，而不是帧缓冲区或后台缓冲区。这个RTT可以被像素着色器操作，以便在最终图像显示之前应用额外的效果。</p><h3 id="CommandBuffer-API"><a href="#CommandBuffer-API" class="headerlink" title="CommandBuffer API"></a>CommandBuffer API</h3><div class="table-container"><table><thead><tr><th>CommandBuffer API</th><th>备注</th></tr></thead><tbody><tr><td>BeginSample</td><td></td></tr><tr><td>SetRenderTarget</td><td>在Unity中使SetRenderTarget之后，在RenderTarget的缓冲区中执行渲染操作。</td></tr></tbody></table></div><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub@master/img2/URP架构.png" alt=""></p><h2 id="URP的使用实例"><a href="#URP的使用实例" class="headerlink" title="URP的使用实例"></a>URP的使用实例</h2><p>还没吃呢</p><h3 id="绘制外发光物体"><a href="#绘制外发光物体" class="headerlink" title="绘制外发光物体"></a>绘制外发光物体</h3><h3 id="热扭曲"><a href="#热扭曲" class="headerlink" title="热扭曲"></a>热扭曲</h3><h3 id="自定义屏幕后处理"><a href="#自定义屏幕后处理" class="headerlink" title="自定义屏幕后处理"></a>自定义屏幕后处理</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;URP概述&quot;&gt;&lt;a href=&quot;#URP概述&quot; class=&quot;headerlink&quot; title=&quot;URP概述&quot;&gt;&lt;/a&gt;URP概述&lt;/h1&gt;&lt;h2 id=&quot;关于URP的架构&quot;&gt;&lt;a href=&quot;#关于URP的架构&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="Unity" scheme="https://www.dante-game.com.cn/categories/Unity/"/>
    
    
    <category term="学习" scheme="https://www.dante-game.com.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="记录" scheme="https://www.dante-game.com.cn/tags/%E8%AE%B0%E5%BD%95/"/>
    
    <category term="经验" scheme="https://www.dante-game.com.cn/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="计算机图形学" scheme="https://www.dante-game.com.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="游戏引擎" scheme="https://www.dante-game.com.cn/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="Unity" scheme="https://www.dante-game.com.cn/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity Shader</title>
    <link href="https://www.dante-game.com.cn/2022/09/25/UnityShader/"/>
    <id>https://www.dante-game.com.cn/2022/09/25/UnityShader/</id>
    <published>2022-09-25T13:37:10.000Z</published>
    <updated>2022-10-25T10:05:16.358Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unity-Shader"><a href="#Unity-Shader" class="headerlink" title="Unity Shader"></a>Unity Shader</h1><p><img src="https://docs.unity3d.com/cn/current/uploads/Main/GraphicsIntroPic.png" alt=""></p><p>这是对于Unity Shader的一个学习记录文档,主要围绕<a href="https://docs.unity3d.com/cn/current/Manual/SL-Properties.html">官方文档</a>对Shader的结构和不同渲染管线的使用进行学习.</p><p>Unity的官方文档中的图形模块包含着以下几个子模块,本文主要探讨着色器部分</p><ul><li>渲染管线</li><li>摄像机</li><li>后期处理</li><li>照明部分</li><li>网格、材质、纹理和着色器</li><li>粒子系统</li><li>创建环境</li><li>天空</li><li>Visual Effects</li><li>优化图形性能</li><li>颜色空间</li></ul><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>本文会先从Shader类进行详细分析,因为本人学习过程中被网络上的教程弄得云里雾里,再加上Shader没有很好的代码补全,故为了方便查阅与了解,以<a href="https://docs.unity3d.com/2021.3/Documentation/Manual/Shaders.html">官方文档</a>切入</p><ul><li><a href="#unity-shader">Unity Shader</a><ul><li><a href="#目录">目录</a></li><li><a href="#shader类">Shader类</a><ul><li><a href="#如何实例化shader对象">如何实例化Shader对象？</a></li><li><a href="#shader对象的结构">Shader对象的结构</a><ul><li><a href="#lod">LOD</a></li><li><a href="#tags">Tags</a></li><li><a href="#commands">commands</a></li><li><a href="#pass">Pass</a></li></ul></li></ul></li><li><a href="#编写shader">编写Shader</a></li></ul></li></ul><h2 id="Shader类"><a href="#Shader类" class="headerlink" title="Shader类"></a>Shader类</h2><p>我们熟知的渲染管线有unity内建渲染管线、URP、HDRP、SRP等<br>这些渲染管线都需要实例化Shader对象，Shader对象和材质决定了场景的外观<br>只有挂载有Shader的材质才能被显示在场景中,一般Unity中创建的基础模型都是挂载着标准着色器的</p><blockquote><p>这里是<a href="https://docs.unity3d.com/2021.3/Documentation/ScriptReference/Shader.html">Shader类的组成</a></p></blockquote><h3 id="如何实例化Shader对象？"><a href="#如何实例化Shader对象？" class="headerlink" title="如何实例化Shader对象？"></a>如何实例化Shader对象？</h3><ul><li>创建着色器资源</li><li>创建Shader Graph资源</li></ul><h3 id="Shader对象的结构"><a href="#Shader对象的结构" class="headerlink" title="Shader对象的结构"></a>Shader对象的结构</h3><p><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub@master/20220926150723.png" alt=""><br>这些是Shader对象的属性,当然现在还用不上,我们不妨从资源文件来看编写好的Shader的结构吧<br>下面是一个.Shader文件的内容,其中包含了材质给Shader对象设置的参数Properties以及多个SubShader</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;ShaderName&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties&#123;</span><br><span class="line">        //传入着色器的参数</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SubShader&#123;</span><br><span class="line">        LOD [value1]</span><br><span class="line">        Tags&#123;...&#125;</span><br><span class="line"></span><br><span class="line">        [commands]</span><br><span class="line"></span><br><span class="line">        Pass&#123;</span><br><span class="line">            Name &quot;PassName&quot;</span><br><span class="line">            //....</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    SubShader&#123;</span><br><span class="line">        LOD [value2]</span><br><span class="line">        Tags&#123;...&#125;</span><br><span class="line">        Pass&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Shader 对象被<strong>子着色器SubShader</strong>分成多个部分，用于兼容不同的硬件、渲染管线和运行时设置。<br>在 SubShader 代码块中，可以：</p><ul><li>使用 LOD 代码块为 SubShader 分配 LOD（细节级别）值。</li><li>使用 Tags 代码块将数据的键值对分配给子着色器。</li><li>使用 ShaderLab 命令将 GPU 指令或着色器代码添加到 SubShader。</li><li>使用 Pass 代码块定义一个或多个通道。</li></ul><h4 id="LOD"><a href="#LOD" class="headerlink" title="LOD"></a>LOD</h4><p><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub@master/20220926151108.png" alt=""></p><p>不同的SubShader可以定义不同的LOD值,这个LOD与模型精细度的LOD不是同样的概念,即该LOD与摄像机距离无关.<br>渲染过程中会将满足渲染条件的SubShader添加到队列中并绘制第一个SubShader,其中满足<code>Shader.globalMaximumLOD &lt;= LOD_Val</code>的SubShader可以被添加到队列,我们可以通过脚本来设置全局最大LOD(默认是没有的)来控制全局的SubShader的切换,也可以访问材质下挂在的Shader实例中的<code>shader.maximumLOD</code>进行局部控制</p><h4 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h4><p>Tags用于以键值对的形式配置SubShader如何被渲染,我们可以罗列以下所有的Tags</p><div class="table-container"><table><thead><tr><th>TagName</th><th>Values</th><th>说明</th></tr></thead><tbody><tr><td>RenderPipeline</td><td></td><td>告诉 Unity 此 SubShader 是否与 URP 或 HDRP 兼容。</td></tr><tr><td>Queue</td><td>Background,Geometry,AlphaTest,<br>Transparent,Overlay,自定义整数</td><td>用于设置渲染队列“Queue” = “[queue name] + [offset]”</td></tr><tr><td>RenderType</td><td>String</td><td>用于标记渲染的类型,可以对不同type进行识别</td></tr><tr><td>DisableBatching</td><td>True,False,LODFading</td><td>禁用动态批处理(会使默认空间变成世界空间造成问题)</td></tr><tr><td>ForceNoShadowCasting</td><td>True,False</td><td>可防止SubShader产生或接收阴影</td></tr><tr><td>IgnoreProjector</td><td>True,False</td><td>是否忽略Projector组件</td></tr><tr><td>CanUseSpriteAtlas</td><td></td></tr><tr><td>PreviewType</td><td>Sphere,Plane,    Skybox</td><td>Unity Editor 使用哪个形状来显示使用此 SubShader 的材质的预览。</td></tr></tbody></table></div><p>Tags在默认情况下会有一些初始值,我们可以在需要的时候进行配置,配置语法如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tags &#123; “[name1]” = “[value1]” “[name2]” = “[value2]”&#125;</span><br></pre></td></tr></table></figure><h4 id="commands"><a href="#commands" class="headerlink" title="commands"></a>commands</h4><p>用于设置渲染状态的命令,如下<br>|commands|作用<br>—|—|<br>AlphaToMask|<br>Blend|混合模式<br>BlendOp|混合操作<br>ColorMask|控制颜色写入RGBA等通道<br>Conservative|<br>Cull|剔除(正反面)<br>Offset|<br>Stencil|模板测试<br>ZClip|深度裁剪<br>ZTest|深度测试<br>ZWrite|深度写入<br>UsePass|根据PassName使用Pass<br>GrabPass|抓取Pass,使用_GrabTexture/Grab内命名来引用纹理。<br>这些指令可以绘制不同有趣的效果,内容很多,可以参考<a href="https://docs.unity3d.com/2021.3/Documentation/Manual/shader-shaderlab-commands.html">文档</a>查看具体内容</p><h4 id="Pass"><a href="#Pass" class="headerlink" title="Pass"></a>Pass</h4><p>Pass是绘制通道,Pass的结构和SubShader类似,如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">    &lt;optional: Name&gt;</span><br><span class="line">    &lt;optional: Tags&gt;</span><br><span class="line">    &lt;optional: Commands&gt;</span><br><span class="line">    &lt;optional: shader code&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>name是pass的名字,可以由command usepass访问</li><li>tags包括 LightMode与自定tags,pass的tag与SubShader的tag不能同名请注意</li><li>commands 同SubShader的Command</li><li>Shader code通过 HLSLPROGRAM ENDHLSL/ CGPROGREAM ENDCG 包裹<h2 id="编写Shader"><a href="#编写Shader" class="headerlink" title="编写Shader"></a>编写Shader</h2>还没吃呢</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Unity-Shader&quot;&gt;&lt;a href=&quot;#Unity-Shader&quot; class=&quot;headerlink&quot; title=&quot;Unity Shader&quot;&gt;&lt;/a&gt;Unity Shader&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://docs.unity3d</summary>
      
    
    
    
    <category term="Unity" scheme="https://www.dante-game.com.cn/categories/Unity/"/>
    
    
    <category term="学习" scheme="https://www.dante-game.com.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="记录" scheme="https://www.dante-game.com.cn/tags/%E8%AE%B0%E5%BD%95/"/>
    
    <category term="经验" scheme="https://www.dante-game.com.cn/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="计算机图形学" scheme="https://www.dante-game.com.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="游戏引擎" scheme="https://www.dante-game.com.cn/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="Unity" scheme="https://www.dante-game.com.cn/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>A Star启发式搜索</title>
    <link href="https://www.dante-game.com.cn/2022/09/24/A%20Star%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/"/>
    <id>https://www.dante-game.com.cn/2022/09/24/A%20Star%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/</id>
    <published>2022-09-24T11:26:43.000Z</published>
    <updated>2022-09-29T12:41:20.683Z</updated>
    
    <content type="html"><![CDATA[<h1 id="A-Star启发式搜索"><a href="#A-Star启发式搜索" class="headerlink" title="A Star启发式搜索"></a>A Star启发式搜索</h1><h2 id="BFS与DFS"><a href="#BFS与DFS" class="headerlink" title="BFS与DFS"></a>BFS与DFS</h2><p>对于常见的搜索算法来说有广度优先搜索(BFS),深度优先搜索(DFS),2个算法都能完成对图的遍历,但2者由于搜索方式的不同有着不同的试用领域.<br><span id="more"></span></p><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><ul><li>递归的或者是利用 <strong>栈(Stack)</strong> 迭代对目标进行遍历<br><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub@master/img2/dfs.gif" alt=""><br>如果只是要找到某一个结果是否存在，那么DFS会更高效。因为DFS会首先把一种可能的情况尝试到底，才会回溯去尝试下一种情况，只要找到一种情况，就可以返回了。但是BFS必须所有可能的情况同时尝试，在找到一种满足条件的结果的同时，也尝试了很多不必要的路径；</li></ul><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><ul><li>利用 <strong>队列(Queue)</strong> 进行遍历<br><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub@master/img2/bfs.gif" alt=""></li></ul><p>如果是要找所有可能结果中最短的，那么BFS回更高效。因为DFS是一种一种的尝试，在把所有可能情况尝试完之前，无法确定哪个是最短，所以DFS必须把所有情况都找一遍，才能确定最终答案（DFS的优化就是剪枝，不剪枝很容易超时）。而BFS从一开始就是尝试所有情况，所以只要找到第一个达到的那个点，那就是最短的路径，可以直接返回了，其他情况都可以省略了，所以这种情况下，BFS更高效。</p><p>我们以以下题目为例,寻找从左上角到右下角的最短路径长度,其中0为障碍,1为可行进路径,可以上下左右移动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;tuple&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int d[4][2] = &#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;</span><br><span class="line">int BFS(vector&lt;vector&lt;int&gt;&gt;&amp; matrix)&#123;</span><br><span class="line">    int m = matrix.size(), n = matrix[0].size();</span><br><span class="line">    queue&lt;pair&lt;int,int&gt;&gt; que;</span><br><span class="line">    que.emplace(0,0);</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        int i,j;</span><br><span class="line">        tie(i,j) = que.front();  que.pop();</span><br><span class="line">        if(i == m-1 &amp;&amp; j == n-1) return matrix[i][j];</span><br><span class="line">        for(auto dd:d)&#123;</span><br><span class="line">            int dx = i + dd[0], dy = j + dd[1];</span><br><span class="line">            if(dx&lt;0 || dy&lt;0 || dx&gt;=m || dy&gt;=n || matrix[dx][dy]==0) continue;</span><br><span class="line">            matrix[dx][dy] = matrix[i][j]+1;</span><br><span class="line">            que.emplace(dx,dy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">   vector&lt;vector&lt;int&gt;&gt; matrix&#123;&#123;1,0,1,1,1,1&#125;,</span><br><span class="line">                              &#123;1,0,1,0,1,1&#125;,</span><br><span class="line">                              &#123;1,0,1,0,1,1&#125;,</span><br><span class="line">                              &#123;1,1,1,0,1,1&#125;&#125;;</span><br><span class="line">    cout&lt;&lt;BFS(matrix);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="A-Star"><a href="#A-Star" class="headerlink" title="A Star"></a>A Star</h2><ul><li>利用 <strong>优先队列(Priority_Queue)</strong> 进行遍历<br><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub@master/img2/Astar.gif" alt=""><br>为了得到2点间的最短路径,我们使用的是BFS,但是BFS会随着步数的增加而逐渐扩大,极其消耗性能,我们能否有指向性的对步长进行扩充呢. 答案就是A<em>启发式搜索<br>A</em>和BFS很相似,但区别在于,A<em>采用的是 <strong>优先队列(Priority_Queue)</strong><br>A</em>会将最有希望的路径优先遍历,若遇到障碍会选择队列中的下一个,在遍历的过程中由大跟堆对下一个遍历目标进行动态维护</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>优先队列采用一个比较函数来对接下来的路径进行排序,选择最有可能达到最短路径的路径.函数如下<script type="math/tex">F = G + H</script><br>F为代价值,我们选出F最小的进行遍历, G为已经经过的步长即代价, H为预估代价<br>H尤为重要,也是A星算法的核心,预估代价是当前遍历点到遍历重点的预估距离,根据不同的情况会有不同的算法,比如只能上下左右移动的网格中我们以横轴差和纵轴差的和作为预估距离,而可以自由移动的搜索中,我们以2点间的距离作为预估距离</p><p>我们还是以以下题目为例,寻找从左上角到右下角的最短路径长度,其中0为障碍,1为可行进路径,可以上下左右移动,其中H为横轴差和纵轴差的和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int d[4][2] = &#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;</span><br><span class="line">int AStar(vector&lt;vector&lt;int&gt;&gt;&amp; matrix)&#123;</span><br><span class="line">    static const int m = matrix.size(),n = matrix[0].size();</span><br><span class="line">    struct node&#123;</span><br><span class="line">        int x,y,f;</span><br><span class="line">        node(int x, int y, int step) : x(x), y(y)&#123;f = step + m-x-1 + n-y-1;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    auto cmp = [](node a, node b)-&gt;bool&#123;return a.f &gt; b.f;&#125;;</span><br><span class="line">    priority_queue&lt;node,vector&lt;node&gt;,decltype(cmp)&gt; que(cmp);</span><br><span class="line">    que.push(node(0,0,0));</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        node cur = que.top(); que.pop();</span><br><span class="line">        if(cur.x == m-1 &amp;&amp; cur.y == n-1) return matrix[cur.x][cur.y];</span><br><span class="line">        for(auto dd:d)&#123;</span><br><span class="line">            int dx = cur.x + dd[0], dy = cur.y + dd[1];</span><br><span class="line">            if(dx&lt;0 || dy&lt;0 || dx&gt;=m || dy&gt;=n || matrix[dx][dy]==0) continue;</span><br><span class="line">            matrix[dx][dy] = matrix[cur.x][cur.y]+1;</span><br><span class="line">            que.push(node(dx,dy,matrix[cur.x][cur.y]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">   vector&lt;vector&lt;int&gt;&gt; matrix&#123;&#123;1,0,1,1,1,1&#125;,</span><br><span class="line">                              &#123;1,0,1,0,1,1&#125;,</span><br><span class="line">                              &#123;1,0,1,0,1,1&#125;,</span><br><span class="line">                              &#123;1,1,1,0,1,1&#125;&#125;;</span><br><span class="line">    cout&lt;&lt;AStar(matrix);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;A-Star启发式搜索&quot;&gt;&lt;a href=&quot;#A-Star启发式搜索&quot; class=&quot;headerlink&quot; title=&quot;A Star启发式搜索&quot;&gt;&lt;/a&gt;A Star启发式搜索&lt;/h1&gt;&lt;h2 id=&quot;BFS与DFS&quot;&gt;&lt;a href=&quot;#BFS与DFS&quot; class=&quot;headerlink&quot; title=&quot;BFS与DFS&quot;&gt;&lt;/a&gt;BFS与DFS&lt;/h2&gt;&lt;p&gt;对于常见的搜索算法来说有广度优先搜索(BFS),深度优先搜索(DFS),2个算法都能完成对图的遍历,但2者由于搜索方式的不同有着不同的试用领域.&lt;br&gt;</summary>
    
    
    
    <category term="算法" scheme="https://www.dante-game.com.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="学习" scheme="https://www.dante-game.com.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="记录" scheme="https://www.dante-game.com.cn/tags/%E8%AE%B0%E5%BD%95/"/>
    
    <category term="经验" scheme="https://www.dante-game.com.cn/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="算法" scheme="https://www.dante-game.com.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>学习资料参考</title>
    <link href="https://www.dante-game.com.cn/2022/09/06/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E5%8F%82%E8%80%83/"/>
    <id>https://www.dante-game.com.cn/2022/09/06/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E5%8F%82%E8%80%83/</id>
    <published>2022-09-06T09:06:23.000Z</published>
    <updated>2022-09-29T13:19:19.513Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇文章用于记录学习过程中受启发很大的文章,都很干,值得反复阅读<br><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub@master/98956123_p0.jpg" alt="配图"></p><span id="more"></span><h2 id="链接列表"><a href="#链接列表" class="headerlink" title="链接列表"></a>链接列表</h2><p><a href="https://zhuanlan.zhihu.com/p/430541328">【游戏开发面经汇总】- 图形学基础篇</a><br><a href="https://www.zhihu.com/question/400628576/answer/2403237801">如何保证UDP可靠传输？</a><br><a href="https://zhuanlan.zhihu.com/p/33464301">猴子也能看懂的pbr</a><br><a href="https://space.bilibili.com/7398208/channel/seriesdetail?sid=1067039">技术美术百人计划</a><br><a href="https://games-cn.org/gamescoursescollection/">GAMES101</a><br><a href="www.games-104.com">GAMES104</a><br><a href="http://t.csdn.cn/7exaw">重心坐标与透视矫正</a><br><a href="http://events.jianshu.io/p/3fef69e2efb6">内置管线Shader升级到URP详细手册</a><br><a href="https://catlikecoding.com/unity/tutorials/">CatLikeCoding</a><br><a href="https://zhuanlan.zhihu.com/p/151238164?utm_campaign=shareopn&amp;utm_medium=social&amp;utm_oi=1071663136624558080&amp;utm_psn=1558905217588080640&amp;utm_source=wechat_session">CatLikeCoding的翻译</a><br><a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@15.0/manual/index.html">URP官方文档</a><br><a href="https://docs.unity3d.com/cn/current/Manual/SL-Properties.html">Unity官方文档</a><br><a href="https://space.bilibili.com/269749034/channel/collectiondetail?sid=48663">动画机部分</a></p><h2 id="待看列表"><a href="#待看列表" class="headerlink" title="待看列表"></a>待看列表</h2><p>DOTween<br><a href="https://note.youdao.com/ynoteshare/index.html?id=fc232bdd46150205a7d5f19b5d1596d6&amp;type=note&amp;_time=1664446995569">羊羊的笔记</a></p><h2 id="待总结的部分"><a href="#待总结的部分" class="headerlink" title="待总结的部分"></a>待总结的部分</h2><p><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub@master/20220925214748.png" alt=""></p><blockquote><p>参考的课程: GAMES101 GAMES104 GAMES202 动画机系列 百人计划</p></blockquote><!--more--><p>这是接下来想要详细总结的部分,要动手编程哦</p><ul><li>渲染管线<br><input type='checkbox' checked>光栅化<br><input type='checkbox'>延迟渲染管线<br><input type='checkbox'>光线追踪</li><li>理论基础<br><input type='checkbox'>向量与矩阵<br><input type='checkbox'>纹理<br><input type='checkbox'>模型与材质<br><input type='checkbox'>伽马矫正<br><input type='checkbox'>LDR与HDR<br><input type='checkbox'>色彩空间<br><input type='checkbox'>GPU硬件架构<br><input type='checkbox'>PC手机图形API<br><input type='checkbox'>移动端TBDR架构</li><li>混合测试<br><input type='checkbox'>EarlyZ和Zprepass<br><input type='checkbox'>混合模式和剔除<br><input type='checkbox'>深度测试与模板测试</li><li>光照模型<br><input type='checkbox' checked>传统光照模型<br><input type='checkbox'>实时阴影<br><input type='checkbox'>SSAO<br><input type='checkbox'>pbr<br><input type='checkbox'>基于物理的相机<br><input type='checkbox'>光线专题</li><li>后处理<br><input type='checkbox'>景深<br><input type='checkbox'>Bloom实现<br><input type='checkbox'>抗锯齿</li><li>Shader效果<br><input type='checkbox'>URP与command buffer<br><input type='checkbox'>常用函数<br><input type='checkbox'>BUMP图<br><input type='checkbox'>flowmap<br><input type='checkbox'>曲面细分与几何着色器<br><input type='checkbox'>shader实战</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这篇文章用于记录学习过程中受启发很大的文章,都很干,值得反复阅读&lt;br&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Ao021/PicPub@master/98956123_p0.jpg&quot; alt=&quot;配图&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="游戏" scheme="https://www.dante-game.com.cn/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
    <category term="学习" scheme="https://www.dante-game.com.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="记录" scheme="https://www.dante-game.com.cn/tags/%E8%AE%B0%E5%BD%95/"/>
    
    <category term="经验" scheme="https://www.dante-game.com.cn/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>光照模型</title>
    <link href="https://www.dante-game.com.cn/2022/09/05/%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B/"/>
    <id>https://www.dante-game.com.cn/2022/09/05/%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B/</id>
    <published>2022-09-05T09:17:53.000Z</published>
    <updated>2022-10-25T10:04:33.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="光照模型"><a href="#光照模型" class="headerlink" title="光照模型"></a>光照模型</h1><h2 id="光学原理"><a href="#光学原理" class="headerlink" title="光学原理"></a>光学原理</h2><p><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub@master/20220925210448.png" alt=""><br>我们肉眼能看见物体是因为光线直接进入到了我们的眼睛,而进入我们眼睛的光线可能是一条直线,也可能是经过无数次反射形成的复杂折现, 那么物体为什么会有颜色呢?</p><span id="more"></span><ul><li><a href="#光照模型">光照模型</a><ul><li><a href="#光学原理">光学原理</a></li><li><a href="#传统光照模型">传统光照模型</a><ul><li><a href="#lambert兰伯特光照模型">lambert兰伯特光照模型</a></li><li><a href="#phong模型">phong模型</a></li><li><a href="#blin-phong模型">blin-phong模型</a></li></ul></li><li><a href="#基于物理的光照模型">基于物理的光照模型</a><ul><li><a href="#光照的组成">光照的组成</a></li><li><a href="#直接光-镜面反射">直接光-镜面反射</a><ul><li><a href="#d--法线分布项ndf">D—法线分布项NDF</a></li><li><a href="#g--几何遮蔽项">G—几何遮蔽项</a></li><li><a href="#f--菲尼尔项">F—菲尼尔项</a></li><li><a href="#暂时停更本文">暂时停更本文</a></li></ul></li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub@master/20220925210829.png" alt=""><br>我们平时最常见的太阳光是由不同频率的光所组成的,人类可以看见的范围是可见光,光线射到物体表面会被物体吸收,由于物体材质不同,对于不同光端的吸收率不同,导致最终我们看见的颜色不同</p><h2 id="传统光照模型"><a href="#传统光照模型" class="headerlink" title="传统光照模型"></a>传统光照模型</h2><p>那么游戏中我们是如何对物体进行绘制的呢</p><script type="math/tex; mode=display">L_0(p,w_o) = L_e(p,w_o)+\int_\Omega f_r(p,w_i,w_o)L_i(p,w_i)n\cdot w_idw_i</script><p>这个很复杂的公式是渲染方程,我们暂时不讨论每个值是什么意思,后续将pbr会仔细说明.</p><p>我们将公式简化为 <script type="math/tex">L_o = L_e + L_i^`</script> ,即最终到我们眼睛中的光(出射光 L_o )是由自发光 L_e 与入射光经过反射后的 L_i` 构成的.<br>而反射后的光线可以简单划分为我们耳熟能详的漫反射与镜面反射,传统光照模型很好的模拟了这2部分.</p><h3 id="lambert兰伯特光照模型"><a href="#lambert兰伯特光照模型" class="headerlink" title="lambert兰伯特光照模型"></a>lambert兰伯特光照模型</h3><p><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub@master/20220925212727.png" alt=""><br>我们之前所说的漫反射还可以进一步被拆分为直接光照形成的漫反射和间接光照形成漫反射,我们以美术中的明暗交界线为例,暗面最暗的地方是与亮面相交的地方,而不是离光线最远的地方.这是因为光线照射到背景布的光经过漫反射射到了球的下半部分,所以球的下半部分也会呈现一部分布的颜色.<br><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub@master/20220925212951.png" alt=""><br>我们回到主题的兰伯特光照模型, 这是一个描述漫反射直接光照部分的光照模型,原理很简单,我们认为相同的受光面积下,与光照垂直的平面更亮,而与光照形成斜面的平面更暗,与光线垂直的面或者被遮挡的面不受光. 那么直接用光线方向与平面的法线方向的夹角即可描述这个关系,这就是兰伯特光照模型.<br><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub@master/20220926095803.png" alt=""><br>关键代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">half4 frag(const v2f i) : SV_TARGET&#123;</span><br><span class="line">    half4 col = tex2D(_MainTex,i.uv);</span><br><span class="line">    float3 n = normalize(i.worldNormal);</span><br><span class="line">    float3 l = normalize(_MainLightPosition.xyz);</span><br><span class="line">    col *= max(0,dot(n,l));</span><br><span class="line">    return col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在早期的应用中为了模拟环境光防止背光面死黑, 还有一种半兰伯特模型,原理也很简单,就是将点乘的结果从(0,1)映射到了(0.5,1),即<code>col *= max(0,dot(n,l))/2+0.5;</code>.效果如下<br><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub@master/20220926100139.png" alt=""></p><h3 id="phong模型"><a href="#phong模型" class="headerlink" title="phong模型"></a>phong模型</h3><p>我们之前所说,物体由直接光的漫反射和镜面反射以间接接光组成,而兰伯特只解决了直接光的漫反射,phong模型将这三个部分抽象为diffuse（漫反射）、specular（镜面反射）、ambient（环境光）<br><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub@master/20220926100654.png" alt=""><br>延续了兰伯特模型的漫反射部分， 镜面反射部分通过判断光线经过反射能够进入相机的部分 ， 环境光作为底色防止死黑， 主要就是镜面反射部分</p><p>phong模型通过入射光线和法向量能够通过简单的几何运算计算出出射光线（很简单，不细说），将出射光线与相机方向做点乘即可判断该点是否能够形成镜面反射，通过求幂来缩减反射范围来描述粗糙度<br><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub@master/20220926103645.png" alt=""><br>可以看出我们已经得到了一个光照信息较为全面的球体,代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">half4 frag(const v2f i) : SV_TARGET&#123;</span><br><span class="line">    half4 col =  _Color*tex2D(_MainTex,i.uv);</span><br><span class="line">    float3 n = normalize(i.worldNormal);</span><br><span class="line">    float3 l = normalize(_MainLightPosition.xyz);</span><br><span class="line">    float3 v = GetWorldSpaceNormalizeViewDir(i.worldPos);</span><br><span class="line">    float3 w_o = normalize(-2*(l-dot(l,n)*n)+l);</span><br><span class="line">    </span><br><span class="line">    half4 diffuse = col*_DiffColor*max(0,dot(n,l))  ;</span><br><span class="line">    half4 spec = _SpecColor*pow(max(0,dot(v,w_o)),_Gloss);</span><br><span class="line">    half4 ambient = _GlossyEnvironmentColor;</span><br><span class="line">    return col*lerp(ambient+diffuse,diffuse+spec,dot(n,l));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="blin-phong模型"><a href="#blin-phong模型" class="headerlink" title="blin-phong模型"></a>blin-phong模型</h3><p><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub@master/20220926104709.png" alt=""><br>phong模型判断的是反射光线与相机视线的重合程度,但计算反射光线的性能消耗似乎有点大,光路总是由入射光-&gt;法线-&gt;反射光这样的对称关系组成的,blin-phong就提出了一种不需要计算反射光线的方法,判断法线与入射光和相机视线的角平分线的重合度,我们把$normalize(l+v)$称作半角向量$h$,那么稍微更改phong模型即可得到更简洁的blin-phong模型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">half4 frag(const v2f i) : SV_TARGET&#123;</span><br><span class="line">    half4 col =  _Color*tex2D(_MainTex,i.uv);</span><br><span class="line">    float3 n = normalize(i.worldNormal);</span><br><span class="line">    float3 l = normalize(_MainLightPosition.xyz - i.worldPos);</span><br><span class="line">    float3 v = GetWorldSpaceNormalizeViewDir(i.worldPos);</span><br><span class="line">    float3 h = normalize(l+v);</span><br><span class="line">    </span><br><span class="line">    half4 diffuse = col*_DiffColor*max(0,dot(n,l))  ;</span><br><span class="line">    half4 spec = _SpecColor*pow(max(0,dot(h,n)),_Gloss);</span><br><span class="line">    half4 ambient = _GlossyEnvironmentColor;</span><br><span class="line">    return col*lerp(ambient+diffuse,diffuse+spec,dot(n,l));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基于物理的光照模型"><a href="#基于物理的光照模型" class="headerlink" title="基于物理的光照模型"></a>基于物理的光照模型</h2><p><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub@master/20220926121216.png" alt=""><br>我们将不同光滑的blin-phong模型作为第一排和第二排中不同光滑度和金属度的pbr模型进行对比。</p><p>很明显第二排的pbr能够表现更多的材质，并且能够反射环境，而非高光点；<br>blin-phong模型则只能表现不同光滑度的塑料材质，可以看出blin-phong模型1-1和pbr模型2-2恨相似，但仔细观察可以发现，除了微弱的环境反射以外，blin-phong1-1的高光部分太过亮了，这也是经验模型的一个通病，不遵循能量守恒（当然也存在模仿能量守恒的经验模型。</p><p>现在我们可以再次看看之前提到过的渲染方程了</p><script type="math/tex; mode=display">L_0(p,w_o) = L_e(p,w_o)+\int_\Omega f_r(p,w_i,w_o)L_i(p,w_i)n\cdot w_idw_i</script><p>其中$f_r$是物理光照模型的关键,双向反射分布函数BRDF描述了入射光出射的情况,以Cook-Torrance光照模型为例,其中</p><script type="math/tex; mode=display">f_r(p,w_i,w_o) = k_d\frac{c}{\pi} + k_s\frac{DFG}{4(w_i\cdot{n})(w_o\cdot{n})}</script><p>看上去很复杂,但其实这个函数也是由2部分组成,漫反射与镜面反射,经验模型其实也可以写成类似的形式,我们以blin-phong为例</p><script type="math/tex; mode=display">f_r(p,w_i,w_o) = k_dc + k_s(n\cdot{h})^{gloss}</script><p>我们之前在Shader中写的blin-phong模型使用的就是这个双向反射函数,其中Kd与Ks均为1,但显而易见,这样很不物理,他不符合能量守恒,高光与反射部分的表现也太过生硬,虽然说是基于物理的光照模型,但实际上还是一种经验模型,不过考虑了许多物理方面的表现</p><h3 id="光照的组成"><a href="#光照的组成" class="headerlink" title="光照的组成"></a>光照的组成</h3><p><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub@master/20220927160126.png" alt=""></p><p>我们将光照分为直接光照与间接光照,每部分的光照都由漫反射与镜面反射组成</p><p>我们之前按所实现的blin-phong主要是由直接漫反射的diffuse,直接镜面反射的specular,与间接光ambient组成<br><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub@master/20220927160353.png" alt=""><br>我们现在不妨一点一点的改进这个blin-phong模型使其变成一个可由光滑度与金属读控制的pbr模型<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">half4 frag(const v2f i) : SV_TARGET&#123;</span><br><span class="line">    half4 col =  _Color*tex2D(_MainTex,i.uv);</span><br><span class="line">    float3 n = normalize(i.worldNormal);</span><br><span class="line">    float3 l = normalize(_MainLightPosition.xyz);</span><br><span class="line">    float3 v = GetWorldSpaceNormalizeViewDir(i.worldPos);</span><br><span class="line">    float3 h = normalize(l+v);</span><br><span class="line">    float nl = max(0,dot(n,l));</span><br><span class="line">    float kd = 1 - _Smooth,ks = _Smooth;</span><br><span class="line">    half4 diff = kd*col;</span><br><span class="line">    half4 spec = ks*(pow(max(0,dot(n,h)),_Gloss));</span><br><span class="line">    half4 direct =  (diff + spec)*nl;</span><br><span class="line">    half4 ambient = _GlossyEnvironmentColor;</span><br><span class="line">    return direct + ambient;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="直接光-镜面反射"><a href="#直接光-镜面反射" class="headerlink" title="直接光-镜面反射"></a>直接光-镜面反射</h3><p>其实blin-phong的直接光漫反射部分实际上相对于pbr只需要除以一个Π即可,这是由于半球积分的原因所造成的</p><p>于是直接光部分我们只需要考虑镜面反射,我们再次拿出这个公式的镜面反射部分<script type="math/tex">k_s\frac{DFG}{4(w_i\cdot{n})(w_o\cdot{n})}</script></p><h4 id="D—法线分布项NDF"><a href="#D—法线分布项NDF" class="headerlink" title="D—法线分布项NDF"></a>D—法线分布项NDF</h4><p>我们的镜面其实是由许多凹凸不平的微平面所组成的,对于发生的镜面反射,光线并不是只沿着我们计算出的理论反射方向所发出,而是会以反射方向为中心呈现一定的分布,blin-phong中所采用的高光其实也是一种分布,但能量不守恒,我们来看公式<script type="math/tex">\frac{a^2}{\pi[(n\cdot{h})^2(a^2-1)+1]^2}</script><br>其中a为粗糙度</p><p>观察一下blin-phong与NDF的区别<br><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub@master/img2/动画2.gif" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub@master/img2/动画.gif" alt=""></p><h4 id="G—几何遮蔽项"><a href="#G—几何遮蔽项" class="headerlink" title="G—几何遮蔽项"></a>G—几何遮蔽项</h4><p>当光线角度与微平面角度相近的时候(小角度)会被遮挡住一小部分,宏观的表现就是边缘光相对垂直光会更暗<br>该项的作用就是描述微平面对于光线的遮蔽情况</p><script type="math/tex; mode=display">G=\frac{n\cdot{l}}{lerp(n\cdot{l},1,k)}×\frac{n\cdot{v}}{lerp(n\cdot{v},1,k)}</script><ul><li>其中直接光照时<script type="math/tex">k = (1+a)^2/8</script></li><li>间接光照时<script type="math/tex">k = a^2/2</script><br><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub@master/img2/2ee.gif" alt=""></li></ul><h4 id="F—菲尼尔项"><a href="#F—菲尼尔项" class="headerlink" title="F—菲尼尔项"></a>F—菲尼尔项</h4><p>Ks代表着镜面反射比例这个值就是F(菲尼尔项),同时菲尼尔项也描述着金属度</p><ul><li><strong>材质(F0 电解质)</strong><br><code>float3 F0</code>是菲尼尔项的重要参数,用于区分导体,表示垂直观察物体时有多少光会被反射,基于经验将其定义为<br><code>float3 F0 = lerp(0.04,baseColor,metallic);</code><br><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub@master/img2/123.gif" alt=""><blockquote><p>这是错误效果,矫正的分母为0时会出现问题,以后有机会纠正</p></blockquote></li></ul><h4 id="暂时停更本文"><a href="#暂时停更本文" class="headerlink" title="暂时停更本文"></a>暂时停更本文</h4>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;光照模型&quot;&gt;&lt;a href=&quot;#光照模型&quot; class=&quot;headerlink&quot; title=&quot;光照模型&quot;&gt;&lt;/a&gt;光照模型&lt;/h1&gt;&lt;h2 id=&quot;光学原理&quot;&gt;&lt;a href=&quot;#光学原理&quot; class=&quot;headerlink&quot; title=&quot;光学原理&quot;&gt;&lt;/a&gt;光学原理&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Ao021/PicPub@master/20220925210448.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;我们肉眼能看见物体是因为光线直接进入到了我们的眼睛,而进入我们眼睛的光线可能是一条直线,也可能是经过无数次反射形成的复杂折现, 那么物体为什么会有颜色呢?&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="https://www.dante-game.com.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="学习" scheme="https://www.dante-game.com.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="记录" scheme="https://www.dante-game.com.cn/tags/%E8%AE%B0%E5%BD%95/"/>
    
    <category term="经验" scheme="https://www.dante-game.com.cn/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="计算机图形学" scheme="https://www.dante-game.com.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="游戏引擎" scheme="https://www.dante-game.com.cn/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>图形渲染管线</title>
    <link href="https://www.dante-game.com.cn/2022/09/03/%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"/>
    <id>https://www.dante-game.com.cn/2022/09/03/%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/</id>
    <published>2022-09-02T17:04:18.000Z</published>
    <updated>2022-09-27T02:15:33.151Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图形渲染管线"><a href="#图形渲染管线" class="headerlink" title="图形渲染管线"></a>图形渲染管线</h1><h2 id="渲染管线概述"><a href="#渲染管线概述" class="headerlink" title="渲染管线概述"></a>渲染管线概述</h2><p>本文用于记录与整理实时渲染管线的流程,参考<a href="https://games-cn.org">GAMES101</a>,<a href="https://games-cn.org">GAMES104</a>,<a href="https://www.bilibili.com/video/BV1L54y1s7xw?p=2&amp;share_source=copy_web&amp;vd_source=da8280c5c3d89248027ccac72e16e11e">技术美术百人计划</a></p><p>图形渲染管线是一系列输入输出组合而成的流水线,即输入顶点数据,得到屏幕上显示的图像,这个过程中会经历很多操作来使得计算机能够将由顶点数据构成的图形显示成由像素块组成的屏幕上的图像</p><blockquote><p>很喜欢GAMES101里的一句话,我们往往会更关注what和why,而how是最不重要的地方<br>因此本文会注重WHAT与WHY,具体的HOW会以超链接形式插入(陆续补充…)</p></blockquote><span id="more"></span><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#图形渲染管线">图形渲染管线</a><ul><li><a href="#渲染管线概述">渲染管线概述</a></li><li><a href="#目录">目录</a></li><li><a href="#渲染管线的分类">渲染管线的分类</a><ul><li><a href="#光栅化渲染管线">光栅化渲染管线</a></li><li><a href="#光线追踪渲染管线">光线追踪渲染管线</a></li></ul></li><li><a href="#整体流程">整体流程</a></li><li><a href="#具体流程">具体流程</a><ul><li><a href="#cpu应用阶段">CPU(应用阶段)</a><ul><li><a href="#1数据的读取">1.数据的读取</a></li><li><a href="#2准备基本数据">2.准备基本数据</a></li><li><a href="#3光源与阴影">3.光源与阴影</a></li><li><a href="#4加速算法">4.加速算法</a></li><li><a href="#5渲染设置">5.渲染设置</a></li><li><a href="#6输出到显存">6.输出到显存</a></li></ul></li><li><a href="#gpu">GPU</a><ul><li><a href="#gpu基础架构">GPU基础架构</a></li><li><a href="#simd-与simt">SIMD 与SIMT</a></li><li><a href="#7几何阶段">7.几何阶段</a></li><li><a href="#8光栅化阶段">8.光栅化阶段</a></li><li><a href="#9逐片元操作">9.逐片元操作</a></li><li><a href="#10后处理">10.后处理</a></li></ul></li></ul></li><li><a href="#总结">总结</a></li><li><a href="#补充">补充</a></li></ul></li></ul><h2 id="渲染管线的分类"><a href="#渲染管线的分类" class="headerlink" title="渲染管线的分类"></a>渲染管线的分类</h2><p>为了更好的说明渲染管线,首先不妨看一看渲染管线的分类和应用。</p><p>渲染管线就是将模型文件中的顶点数据转化成由屏幕上像素方块组成的图像的过程。可以说由AI中制作的矢量图形转换成PS中的像素图像这个过程也算是一种渲染管线。但我们平时玩游戏或者建模所接触到的渲染管线是面向三维的模型的。</p><h3 id="光栅化渲染管线"><a href="#光栅化渲染管线" class="headerlink" title="光栅化渲染管线"></a>光栅化渲染管线</h3><p>如游戏中的实时渲染管线，大多采用的是<font color = red><b>光栅化渲染管线</b></font>，即将顶点挨个变成像素，通过插值和计算补全由顶点组成的三角的空间,最终得到图像.这也是我们今天要主要介绍的渲染管线。</p><p><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub@master/20220925202803.png" alt=""></p><p>光栅化的渲染管线也有 <strong>前向渲染管线</strong> 和 <strong>延迟渲染管线</strong>等分支，在unity中我们也可以通过URP、HDRP等基于可编程渲染管线的模板来自定义光栅化渲染管线。我们可以巧妙的利用各种缓存和绘制方式（不同的绘制顺序，规定绘制的范围）等来实现各种效果与性能的优化。所以有许多不同的光栅化渲染管线。</p><h3 id="光线追踪渲染管线"><a href="#光线追踪渲染管线" class="headerlink" title="光线追踪渲染管线"></a>光线追踪渲染管线</h3><p><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub@master/20220925203932.png" alt=""><br>如果说在游戏中的渲染管线是为了满足实时性的话，那么光线追踪渲染管线就是为了满足真实性与准确性，我们愿意牺牲大量的时间对光线的反射进行计算。<br>光线追踪的渲染管线不是将顶点换算到像素块上然后进行计算，而是从像素块出发根据光路可逆的原则判断有哪些光线会被该像素点所接收（即判断射到人眼的同一方向上的所有光线），根据光线计算的不同方向（是否逆路径）将光线追踪分为了前向和后向光线追踪。<br>这并不是讨论的重点,可以看<a href="https://www.bilibili.com/video/BV1n5411M7pa/?spm_id_from=333.337.search-card.all.click&amp;vd_source=26f358375b19c380eea8013ae3143ec5">《十分钟看懂光线追踪到底是怎么追的？》</a>这个视频了解更多</p><blockquote><p>值得一提的是游戏中的光线追踪有的采用的高度优化的光线追踪渲染管线(如我的世界RTX),有的采用的是光栅化渲染管线加上光线追踪形成的部分信息</p></blockquote><h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><p>那么让我们来好好看一看光栅化的具体流程吧,记住输入是 顶点数据(.obj等文件),输出是屏幕上的像素</p><div class="table-container"><table><thead><tr><th style="text-align:center">阶段</th><th style="text-align:center">内容</th></tr></thead><tbody><tr><td style="text-align:center">应用阶段:</td><td style="text-align:center">粗颗粒剔除, 渲染设置, 准备基本数据, 输出到几何阶段</td></tr><tr><td style="text-align:center">几何阶段:</td><td style="text-align:center">顶点着色器, 曲面细分, 几何着色器, 顶点裁剪, 屏幕映射</td></tr><tr><td style="text-align:center">光栅化阶段:</td><td style="text-align:center">三角形设置, 三角形遍历, 片段着色器</td></tr><tr><td style="text-align:center">逐片元操作:</td><td style="text-align:center">裁剪测试, 透明度测试, 深度测试, 模板测试, 混合</td></tr><tr><td style="text-align:center">后处理:</td><td style="text-align:center">泛光 边缘检测 模糊 景深 HDR FXAA</td></tr></tbody></table></div><h2 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h2><p>渲染管线相当于一个流水线车间,加工产品是数据,磁盘上的数据会经过 cpu-&gt;gpu 这2个车间,最终加工成屏幕上像素点中的色彩信息</p><h3 id="CPU-应用阶段"><a href="#CPU-应用阶段" class="headerlink" title="CPU(应用阶段)"></a>CPU(应用阶段)</h3><h4 id="1-数据的读取"><a href="#1-数据的读取" class="headerlink" title="1.数据的读取"></a>1.数据的读取</h4><p><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/20210524125640.png" alt=""></p><p>我们的模型与贴图是存储在磁盘上的,这些数据是其他软件的加工品如3dmax,maya,blender等,里面存储着顶点,法线,uv等等我们常见的信息,当然也包含着一些为了更好的效果或者是更快的速度为软件所独有一些信息,这一部分信息是无法被有效利用的.<br>这些数据经过规整化(不同软件可能有着不同的数据定义方式),剔除掉不可用的数据,加载到了内存上以待进一步的处理.</p><h4 id="2-准备基本数据"><a href="#2-准备基本数据" class="headerlink" title="2.准备基本数据"></a>2.准备基本数据</h4><p>对于需要渲染的数据进行准备</p><ul><li>场景物体数据<ul><li>物体的变换数据(位置,缩放,旋转等)</li><li>物体的网格数据(顶点,贴图,法线,切线等)</li></ul></li><li>光源数据<ul><li>光源类型(方向光,点光,聚光等)</li><li>光源的位置,角度,方向,颜色等</li></ul></li><li>摄像机数据<ul><li>位置,方向,远近裁剪平面等</li><li>正交/透视模式</li><li>屏幕尺寸/比例等</li></ul></li></ul><h4 id="3-光源与阴影"><a href="#3-光源与阴影" class="headerlink" title="3.光源与阴影"></a>3.光源与阴影</h4><ul><li>设置光源<ul><li>方向光:颜色,方向等</li><li>点光:颜色,位置,范围等</li><li>聚光:颜色,位置,方向,内外圆锥角等</li></ul></li><li>设置阴影<ul><li>是否需要阴影</li><li>阴影参数:对应光源,阴影强度,级联参数,深度偏移,近平面偏移等</li></ul></li><li>逐光源绘制阴影贴图<ul><li>近平面偏移</li><li>逐级联<ul><li>计算当前光源+级联对应的观察矩阵、投影矩阵、阴影贴图的视口区域</li><li>绘制到阴影贴图</li></ul></li></ul></li></ul><h4 id="4-加速算法"><a href="#4-加速算法" class="headerlink" title="4.加速算法"></a>4.加速算法</h4><ul><li>可见光裁剪:裁剪掉距离过远,光线与视锥不相交的光源</li><li>场景物体裁剪:裁剪被遮挡,不在视锥范围内的物体<ul><li>八叉树</li><li>BSP树</li><li>K-D树</li><li>BVH包围盒</li></ul></li></ul><h4 id="5-渲染设置"><a href="#5-渲染设置" class="headerlink" title="5.渲染设置"></a>5.渲染设置</h4><ul><li>绘制设置<ul><li>使用不同着色器</li><li>合批方式(动态,静态批处理,GPU instance)</li></ul></li><li>绘制物体的顺序<ul><li>相对摄像机的距离</li><li>材质RenderQueue</li><li>UICanvas</li></ul></li><li>渲染目标<ul><li>FrameBuffer</li><li>RenderTexture</li></ul></li><li>渲染模式<ul><li>前向渲染</li><li>延迟渲染</li></ul></li></ul><h4 id="6-输出到显存"><a href="#6-输出到显存" class="headerlink" title="6.输出到显存"></a>6.输出到显存</h4><p>将之前处理好的顶点数据和其他数据如(mvp变换矩阵,纹理贴图等)按照渲染设置输出到GPU</p><h3 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h3><p><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub@master/20220905140016.png" alt=""></p><h4 id="GPU基础架构"><a href="#GPU基础架构" class="headerlink" title="GPU基础架构"></a>GPU基础架构</h4><p><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub@master/20220905131333.png" alt=""></p><p>GPU如图所示可以简单的划分为3个层级,</p><ul><li>GPU: 如图左下侧所示,主要由SM,DRAM(显存),L2(二级缓存)组成</li><li>GPC: 图形处理集群，一个GPU有多个GPC，一个GPC包含多个SM</li><li>SM: 计算单元，一个GPU有多个SM,每个SM如图右侧所示</li><li>Texture Units: 纹理处理单元，可以提取和过滤纹理</li><li>Core: 允许不同处理器同时处理数据的并行处理器</li><li>Warp: 在SM里面将SP（thread）进行分组，一般每32个thread称为一个warp</li></ul><blockquote><p>LD/ST：load/store，用于内存操作的，读取单元。<br>SFU：special function unit，来执行超指令（transcendental instruction）如正弦、余弦、倒数和平方根等函数。每个 SFU 一次执行一个线程块中一个线程的一条指令</p></blockquote><h4 id="SIMD-与SIMT"><a href="#SIMD-与SIMT" class="headerlink" title="SIMD 与SIMT"></a>SIMD 与SIMT</h4><p><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub@master/20220905133545.png" alt=""></p><p><strong>SIMD</strong> (Single Instruction Multiple Data)</p><ul><li>单指令处理多数据,处理单元可以同时对多个数据点执行相同的操作(如向量加法)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub@master/20220905134337.png" alt=""></p><p><strong>SIMT</strong> (Single Instruction Multiple Threads)</p><ul><li>单指令处理多线程,并行计算中使用的一种执行模型，将单指令多数据(SIMD)与多线程结合在一起</li></ul><p>这样的硬件构成使得GPU能够轻松进行大量的浮点运算,尤为适合进行大量多维度数据的运算,当然也能通过硬件支持如sin,cos一类较为复杂的数学运算(机器学习中也使用到了GPU进行加速), 现代GPU更是将光线追踪的运算硬件化来适应实时光线追踪.</p><blockquote><p>注意这只是电脑的GPU架构,在移动手机端的架构更加特殊,所以所使用的渲染管线也相应的有一定的调整(TBDR基于块元的渲染),这里不多做叙述</p><h4 id="7-几何阶段"><a href="#7-几何阶段" class="headerlink" title="7.几何阶段"></a>7.几何阶段</h4></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/20210525075935.png" alt=""></p><ul><li>顶点着色<ul><li>视图变换(MVP): <code>将模型坐标空间转换到了裁剪坐标空间</code></li><li>顶点着色</li></ul></li><li>曲面细分着色器-&gt;几何着色器: <code>在原有的顶点数据基础上进一步增加新的顶点数据来实现不同的效果</code><ul><li>曲面细分</li><li>几何着色</li></ul></li><li>投影<ul><li>除以w将投影坐标系转换到NDC标准坐标系</li></ul></li><li>裁剪<ul><li>视锥体裁剪(CVV)</li><li>正面背面剔除</li></ul></li><li>屏幕映射: <code>将裁剪空间转换到屏幕空间</code><ul><li>视口转化(xy分别映射到WH,z映射到远近平面,平移+缩放)</li></ul></li></ul><h4 id="8-光栅化阶段"><a href="#8-光栅化阶段" class="headerlink" title="8.光栅化阶段"></a>8.光栅化阶段</h4><ul><li>三角形设置(计算三角形/直线边界信息,图元装配)</li><li>三角形遍历(检查像素是否被三角形覆盖,若在三角形内计算插值(<a href="http://t.csdn.cn/7exaw">重心坐标与透视矫正</a>),更新深度)</li><li>抗锯齿(MSAA,SSAA,FXAA/TXAA(后处理))</li></ul><h4 id="9-逐片元操作"><a href="#9-逐片元操作" class="headerlink" title="9.逐片元操作"></a>9.逐片元操作</h4><ul><li>片段着色: <code>绘制阶段,在这之前都没有绘图操作</code></li><li>颜色混合<ul><li>透明度测试</li><li>深度测试</li><li>模板测试</li></ul></li><li>目标缓冲区</li></ul><h4 id="10-后处理"><a href="#10-后处理" class="headerlink" title="10.后处理"></a>10.后处理</h4><ul><li>泛光</li><li>边缘检测</li><li>模糊</li><li>景深</li><li>HDR</li><li>FXAA<br>……</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">flowchart TB</span><br><span class="line">subgraph 渲染管线</span><br><span class="line">  subgraph 应用阶段</span><br><span class="line">    direction LR</span><br><span class="line">    数据--粗颗粒剔除--&gt;渲染设置</span><br><span class="line">  end</span><br><span class="line">  subgraph 几何阶段</span><br><span class="line">    direction LR</span><br><span class="line">    顶点着色器--&gt;曲面细分着色器--&gt;几何着色器--&gt;投影--&gt;裁剪--&gt;屏幕映射</span><br><span class="line">  end</span><br><span class="line">  subgraph 光栅化阶段</span><br><span class="line">    direction LR</span><br><span class="line">    三角形设置--&gt;三角形遍历--&gt;片段着色器</span><br><span class="line">  end</span><br><span class="line">  subgraph 逐片元操作</span><br><span class="line">    direction LR</span><br><span class="line">    裁剪测试--&gt;透明度测试--&gt;模板测试--&gt;深度测试</span><br><span class="line">  end</span><br><span class="line">  后处理</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>渲染管线是一个复杂的流水线, 理解起来会有很多误区, 这里简单的介绍了一下通用的渲染管线以加深理解.如果以一个顶点的一生来描述渲染管线的话:</p><ul><li><strong>应用</strong><br>存储在磁盘上的顶点A被选择有效数据后加载到内存上,cpu对他的同胞数据进行了各种处理,处理结果会最终作用到自己身上,顶点A被识别为三角形的一员送入了GPU;</li><li><strong>几何</strong><br>GPU中顶点A经历了模型矩阵,视口矩阵,投影矩阵的变换;模型被细分后加入了许多新顶点,顶点A随之进行了位置的调整,加入了新的三角形中;顶点A除以自身的w后被转换到了一个以原点为中心向各轴延展1的正方形空间中,没有被划分进来的顶点被裁剪掉了,划分了一半的三角形为了维持形状新增了新的顶点进行补全,根据三角形绘制时针方向判断正反面,不该被渲染的面也被剔除掉了,顶点A再次转换到了屏幕空间中(0-W,0-H,Near-Far),顶点A覆盖了像素B,接下来就是像素B的一生了</li><li><strong>光栅化</strong><br>像素B是顶点A在其坐标所对应的像素,但他属于许多三角形,三角形通过顶点的插值决定了三角形在像素B上的数据,像素B要根据深度测试,alpha测试等判断是否要采用三角形的数据,同样应用阶段的各种数据也会作用到像素B的生成上(如阴影,光照等),像素B经过各种数据的混合最终变成了屏幕上所显示的像素</li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul><li>各种测试的相对顺序：裁剪-&gt;Alpha-&gt;模板-&gt;深度</li><li>Early-Z<ul><li>Early-Z是一种提前深度测试的技术，它位于光栅化阶段之后，像素处理阶段之前，目的是减少进入像素着色阶段的片段，优化性能。Early-Z会带来透明测试的冲突，例如某个片元A虽然遮挡了另一个片元B，但A却是透明的，GPU应当渲染的是片元B，这就产生了矛盾，这就是透明度测试会导致性能下降的原因(因为无法用Early-Z)，但是有一种叫PreZ的技术可以解决这个问题，参考上面的链接，不再详述。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;图形渲染管线&quot;&gt;&lt;a href=&quot;#图形渲染管线&quot; class=&quot;headerlink&quot; title=&quot;图形渲染管线&quot;&gt;&lt;/a&gt;图形渲染管线&lt;/h1&gt;&lt;h2 id=&quot;渲染管线概述&quot;&gt;&lt;a href=&quot;#渲染管线概述&quot; class=&quot;headerlink&quot; title=&quot;渲染管线概述&quot;&gt;&lt;/a&gt;渲染管线概述&lt;/h2&gt;&lt;p&gt;本文用于记录与整理实时渲染管线的流程,参考&lt;a href=&quot;https://games-cn.org&quot;&gt;GAMES101&lt;/a&gt;,&lt;a href=&quot;https://games-cn.org&quot;&gt;GAMES104&lt;/a&gt;,&lt;a href=&quot;https://www.bilibili.com/video/BV1L54y1s7xw?p=2&amp;amp;share_source=copy_web&amp;amp;vd_source=da8280c5c3d89248027ccac72e16e11e&quot;&gt;技术美术百人计划&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;图形渲染管线是一系列输入输出组合而成的流水线,即输入顶点数据,得到屏幕上显示的图像,这个过程中会经历很多操作来使得计算机能够将由顶点数据构成的图形显示成由像素块组成的屏幕上的图像&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;很喜欢GAMES101里的一句话,我们往往会更关注what和why,而how是最不重要的地方&lt;br&gt;因此本文会注重WHAT与WHY,具体的HOW会以超链接形式插入(陆续补充…)&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="https://www.dante-game.com.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="学习" scheme="https://www.dante-game.com.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="记录" scheme="https://www.dante-game.com.cn/tags/%E8%AE%B0%E5%BD%95/"/>
    
    <category term="经验" scheme="https://www.dante-game.com.cn/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="计算机图形学" scheme="https://www.dante-game.com.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="游戏引擎" scheme="https://www.dante-game.com.cn/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL_03_坐标系统与摄像机</title>
    <link href="https://www.dante-game.com.cn/2021/05/25/OpenGL-03-%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%91%84%E5%83%8F%E6%9C%BA/"/>
    <id>https://www.dante-game.com.cn/2021/05/25/OpenGL-03-%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%91%84%E5%83%8F%E6%9C%BA/</id>
    <published>2021-05-25T00:55:42.000Z</published>
    <updated>2022-09-02T06:49:21.358Z</updated>
    
    <content type="html"><![CDATA[<h1 id="坐标系统与摄像机"><a href="#坐标系统与摄像机" class="headerlink" title="坐标系统与摄像机"></a>坐标系统与摄像机</h1><p>本篇简单的记录了关于坐标系统的机制与摄像机,为了方便理解去掉了数学内容,详细的后面会写</p><h2 id="坐标系统"><a href="#坐标系统" class="headerlink" title="坐标系统"></a>坐标系统</h2><p><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/20210525075935.png" alt=""></p><p>我们先来认识这张图,为了将坐标从一个坐标系转换到另一个坐标系，我们需要用到几个转换矩阵，最重要的几个分别是<strong>模型(Model)</strong> 、<strong>视图(View)</strong> 、<strong>投影(Projection)</strong> 三个矩阵。首先，顶点坐标开始于<strong>局部空间(Local Space)</strong> ，称为<strong>局部坐标(Local Coordinate)</strong> ，然后经过<strong>世界坐标(World Coordinate)</strong> ，<strong>观察坐标(View Coordinate)</strong> ，<strong>裁剪坐标(Clip Coordinate)</strong> ，并最后以<strong>屏幕坐标(Screen Coordinate)</strong> 结束。</p><span id="more"></span><p>我们先理解每个矩阵的作用,从开始到结尾一共经过了四个过程:</p><ol><li>Model Matrix</li><li>View Matrix</li><li>Projection Matrix</li><li>Viewport Transform</li></ol><ul><li><strong>Model Matrix</strong><br>我们知道模型坐标以点位置的形式传入着色器, 这些点的参考原点就是本地坐标的原点,即使模型做了变化,这些变化都是相对于原点的变化. 可以理解为3D软件中模型中心点的意思,我们的操作都是以中心点为参照进行的</li><li><strong>View Matrix</strong><br>显然,这样并不能让模型很直观的显示出来,所以我们需要一个View Matrix来设置一个摄像机来观察模型,具体会在下一个点提到.</li><li><p><strong>Projection Matrix</strong><br>我们现在得到了View Space,但这样的视图显然并不是我们想要的最终结果. 通过Projection Matrix我们将指定范围的坐标转换到标准化设备坐标系中(-1,1). 这是一个投影(Projection)的过程, 他会减裁掉多余的坐标保留我们所看到的部分,得到<strong>裁剪坐标(Clip Coordinate)</strong>. 投影矩阵除了起到减裁的作用,还能够指定投影的方式, <strong>正射投影(Orthographic Projection)</strong> 将坐标以正交的方式投影到标准坐标系,呈现中国画的透视关系;而<strong>透视投影(Perspective Projection)</strong> 创建一定角度的平截头体来实现我们人眼所见的透视关系,如下图:</p><p><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/20210525075953.png" alt=""><br>我们可以简单看看代码</p><p><strong>正射投影</strong><code>glm::ortho(0.0f, 800.0f, 0.0f, 600.0f, 0.1f, 100.0f);</code>前两个参数指定了平截头体的左右坐标，第三和第四参数指定了平截头体的底部和上部,第五和第六个参数则定义了近平面和远平面的距离。这个指定的投影矩阵将处于这些x，y，z范围之间的坐标转换到标准化设备坐标系中。</p><p><strong>透视投影</strong><code>glm::mat4 proj = glm::perspective(45.0f, (float)width/(float)height, 0.1f, 100.0f);</code>它的第一个参数定义了<strong>fov</strong> 的值,第二个参数设置了宽高比，第三和第四个参数设置了平截头体的近和远平面。</p><blockquote><p>如果只是片段的一部分例如三角形，超出了裁剪体积(Clipping Volume)，则OpenGL会重新构建三角形以使一个或多个三角形能适应在裁剪范围内。</p></blockquote></li><li><p><strong>Viewport Transform</strong></p><p>一旦所有顶点被转换到裁剪空间，最终的操作——<strong>透视划分(Perspective Division)</strong> 将会执行，在这个过程中我们将位置向量的x，y，z分量分别除以向量的齐次w分量；透视划分是将4维裁剪空间坐标转换为3维标准化设备坐标。这一步会在每一个顶点着色器运行的最后被自动执行。</p><p>在这一阶段之后，坐标经过转换的结果将会被映射到屏幕空间(由<code>glViewport</code>设置)且被转换成片段。</p></li></ul><p>$V<em>{clip} = M</em>{projection} \cdot M<em>{view} \cdot M</em>{model} \cdot V_{local}$就是这些矩阵变化的最终组合,他将被传入着色器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#version 330 core</span><br><span class="line">layout (location = 0) in vec3 position;</span><br><span class="line">...</span><br><span class="line">uniform mat4 model;</span><br><span class="line">uniform mat4 view;</span><br><span class="line">uniform mat4 projection;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    // 注意从右向左读</span><br><span class="line">    gl_Position = projection * view * model * vec4(position, 1.0f);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="摄像机"><a href="#摄像机" class="headerlink" title="摄像机"></a>摄像机</h2><p>摄像机如何才能满足我们的需求呢, 我们不妨摄像摄像机所需的参数:  摄像机的位置, 摄像机的方向, 摄像机的变换</p><ul><li>摄像机的位置<br>我们通过对目标的相对移动来控制摄像机的位置, 故我们可以相对于原点传入摄像机位置的反方向.</li><li>摄像机的方向<br>我们可以指定目标的位置,通过向量相减我们可以得到摄像机的朝向向量,反之亦然</li><li>摄像机的变换<br>我们在各种三维软件中所认识的摄像机都能通过各种变换来得到一个理想的视角, 想要进行这些变换就需要对摄像机进行矩阵运算,但现在我们并没有一个属于摄像机的坐标空间, 所以我们要利用前面向量和矩阵中的方法来建立一个摄像机坐标空间<details>我们需要的另一个向量是一个右向量(Right Vector)，它代表摄像机空间的x轴的正方向。为获取右向量我们需要先使用一个小技巧：定义一个上向量(Up Vector)。我们把上向量和第二步得到的摄像机方向向量进行叉乘。两个向量叉乘的结果就是同时垂直于两向量的向量，因此我们会得到指向x轴正方向的那个向量(如果我们交换两个向量的顺序就会得到相反的指向x轴负方向的向量)：现在我们已经有了x轴向量和z轴向量，获取摄像机的正y轴相对简单；我们把右向量和方向向量(Direction Vector)进行叉乘;</details></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f); </span><br><span class="line">glm::vec3 cameraRight = glm::normalize(glm::cross(up, cameraDirection));</span><br><span class="line">glm::vec3 cameraUp = glm::cross(cameraDirection, cameraRight);</span><br></pre></td></tr></table></figure><p>可以简单的看看官方给出的<a href="https://learnopengl.com/code_viewer.php?code=getting-started/camera_zoom">源码</a>理解下</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;坐标系统与摄像机&quot;&gt;&lt;a href=&quot;#坐标系统与摄像机&quot; class=&quot;headerlink&quot; title=&quot;坐标系统与摄像机&quot;&gt;&lt;/a&gt;坐标系统与摄像机&lt;/h1&gt;&lt;p&gt;本篇简单的记录了关于坐标系统的机制与摄像机,为了方便理解去掉了数学内容,详细的后面会写&lt;/p&gt;
&lt;h2 id=&quot;坐标系统&quot;&gt;&lt;a href=&quot;#坐标系统&quot; class=&quot;headerlink&quot; title=&quot;坐标系统&quot;&gt;&lt;/a&gt;坐标系统&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Ao021/PicPub/20210525075935.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们先来认识这张图,为了将坐标从一个坐标系转换到另一个坐标系，我们需要用到几个转换矩阵，最重要的几个分别是&lt;strong&gt;模型(Model)&lt;/strong&gt; 、&lt;strong&gt;视图(View)&lt;/strong&gt; 、&lt;strong&gt;投影(Projection)&lt;/strong&gt; 三个矩阵。首先，顶点坐标开始于&lt;strong&gt;局部空间(Local Space)&lt;/strong&gt; ，称为&lt;strong&gt;局部坐标(Local Coordinate)&lt;/strong&gt; ，然后经过&lt;strong&gt;世界坐标(World Coordinate)&lt;/strong&gt; ，&lt;strong&gt;观察坐标(View Coordinate)&lt;/strong&gt; ，&lt;strong&gt;裁剪坐标(Clip Coordinate)&lt;/strong&gt; ，并最后以&lt;strong&gt;屏幕坐标(Screen Coordinate)&lt;/strong&gt; 结束。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="https://www.dante-game.com.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="学习" scheme="https://www.dante-game.com.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="记录" scheme="https://www.dante-game.com.cn/tags/%E8%AE%B0%E5%BD%95/"/>
    
    <category term="经验" scheme="https://www.dante-game.com.cn/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="计算机图形学" scheme="https://www.dante-game.com.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="OpenGL" scheme="https://www.dante-game.com.cn/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL_02_向量和矩阵</title>
    <link href="https://www.dante-game.com.cn/2021/05/24/OpenGL-02-%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B5/"/>
    <id>https://www.dante-game.com.cn/2021/05/24/OpenGL-02-%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B5/</id>
    <published>2021-05-24T08:47:26.000Z</published>
    <updated>2022-09-02T06:49:21.358Z</updated>
    
    <content type="html"><![CDATA[<h1 id="向量和矩阵"><a href="#向量和矩阵" class="headerlink" title="向量和矩阵"></a>向量和矩阵</h1><p>默认大家都学过向量和矩阵,这里就记录一些核心的东西</p><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><h3 id="向量点积-dot-product"><a href="#向量点积-dot-product" class="headerlink" title="向量点积(dot product)"></a>向量点积(dot product)</h3><p>向量点积，也称为向量的数量积，点积的结果是一个标量，其定义为$|\ A\ |\cdot{|\ B\ |\cos\theta}$,其几何意义如下,一般用于计算投影和夹角<br><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/20210524154830.png" alt=""></p><span id="more"></span><h3 id="向量的叉积-cross-product"><a href="#向量的叉积-cross-product" class="headerlink" title="向量的叉积(cross product)"></a>向量的叉积(cross product)</h3><p>两个向量a和b的叉积,结果是一个向量$c=a×b$,c的方向垂直于a和b，据右手规则来确定；c的大小等于  $|c| = |a||b|\sin\theta$<img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/20210524155621.png" alt=""></p><blockquote><p>$a×b=−b×a$</p></blockquote><p>在利用以坐标形式表示向量a和b时，在3D空间中，叉积的结果用矩阵表示为:<br>$c = a×b\=<br>\begin{bmatrix}<br>i&amp;j&amp;k\<br>a_x&amp;a_y&amp;a_z\<br>b_x&amp;b_y&amp;b_z\<br>\end{bmatrix} $</p><p>$=<br>\begin{bmatrix}<br>a_y&amp;a_z\<br>b_y&amp;b_z<br>\end{bmatrix}i-<br>\begin{bmatrix}<br>a_x&amp;a_z\<br>b_x&amp;b_z<br>\end{bmatrix}j+<br>\begin{bmatrix}<br>a_x&amp;a_y\<br>b_x&amp;b_y<br>\end{bmatrix}k$</p><p>$=<br>\begin{bmatrix}<br>a_yb_z-a_zb_y\<br>a_xb_z-a_zb_x\<br>a_xb_y-a_yb_x<br>\end{bmatrix}<br>$</p><blockquote><p>其中 i,j,k为x,y,z三个方向上的单位向量</p></blockquote><p>叉积的几何意义<br>叉积的模可以视为以a和b为两边的平行四边形的面积，如下图所示<br><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/20210524162017.png" alt=""><br>同时在OpenGL中还可以用来确定第三个方向 $up=dir×side$</p><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><h3 id="矩阵和矩阵乘法"><a href="#矩阵和矩阵乘法" class="headerlink" title="矩阵和矩阵乘法"></a>矩阵和矩阵乘法</h3><p><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/20210524162238.png" alt=""><br>向量的点积公式可以重新表示为:<br>$a=(a1,b2,⋯,cn),\ b=(b1,b2,⋯,bn)$</p><p>$a\cdot{b}=a<em>1b_1+a_2b_2+\dots+a_nb_n\$<br>$=\sum</em>{i=1}^na_ib_i\$<br>$=a^Tb$</p><h3 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h3><p><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/20210524163031.png" alt=""></p><h3 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h3><p>对于n阶方阵A，如果存在一个n阶方阵B使得:$AB=BA=I_{nxn}$</p><ul><li>逆矩阵的应用意义<br>在3D图形处理中，用一个变换矩阵乘以向量，代表了对原始图形进行了某种变换，例如缩小，旋转等，逆矩阵表示这个操作的逆操作，也就是能够撤销这一操作。例如对一个向量$v$用矩阵$M$相乘，然后再用$M^{−1}$相乘，则能得到原来的向量$v$</li></ul><blockquote><p>注意转换矩阵应用顺序 当用矩阵$A,B,C$转换向量$v$时，如果$v$用行向量记法，则矩阵按转换顺序从左往右列出，表达为$vABC$;如果$v$采用列向量记法，则转换矩阵应该放在左边，并且转换从右往左发生，对应的转换记为$CBAv$</p></blockquote><h3 id="正交矩阵"><a href="#正交矩阵" class="headerlink" title="正交矩阵"></a>正交矩阵</h3><p>对于方阵M，当且仅当$M$与其转置矩阵$M^T$的乘积等于单位矩阵时，称其为正交矩阵。即：$MM^T=E$正交矩阵的一大优势在于，计算逆矩阵时，只需要对原矩阵转置即可，从而减少了计算量。在3D图形处理中的旋转和镜像变换都是正交的</p><blockquote><p>正交矩阵一定是可逆的</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;向量和矩阵&quot;&gt;&lt;a href=&quot;#向量和矩阵&quot; class=&quot;headerlink&quot; title=&quot;向量和矩阵&quot;&gt;&lt;/a&gt;向量和矩阵&lt;/h1&gt;&lt;p&gt;默认大家都学过向量和矩阵,这里就记录一些核心的东西&lt;/p&gt;
&lt;h2 id=&quot;向量&quot;&gt;&lt;a href=&quot;#向量&quot; class=&quot;headerlink&quot; title=&quot;向量&quot;&gt;&lt;/a&gt;向量&lt;/h2&gt;&lt;h3 id=&quot;向量点积-dot-product&quot;&gt;&lt;a href=&quot;#向量点积-dot-product&quot; class=&quot;headerlink&quot; title=&quot;向量点积(dot product)&quot;&gt;&lt;/a&gt;向量点积(dot product)&lt;/h3&gt;&lt;p&gt;向量点积，也称为向量的数量积，点积的结果是一个标量，其定义为$|\ A\ |\cdot{|\ B\ |\cos\theta}$,其几何意义如下,一般用于计算投影和夹角&lt;br&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Ao021/PicPub/20210524154830.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="https://www.dante-game.com.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="学习" scheme="https://www.dante-game.com.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="记录" scheme="https://www.dante-game.com.cn/tags/%E8%AE%B0%E5%BD%95/"/>
    
    <category term="经验" scheme="https://www.dante-game.com.cn/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="计算机图形学" scheme="https://www.dante-game.com.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="OpenGL" scheme="https://www.dante-game.com.cn/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL_01_OpenGL的绘图基本流程与概念</title>
    <link href="https://www.dante-game.com.cn/2021/05/24/OpenGL_01_OpenGL%E7%9A%84%E7%BB%98%E5%9B%BE%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E4%B8%8E%E6%A6%82%E5%BF%B5/"/>
    <id>https://www.dante-game.com.cn/2021/05/24/OpenGL_01_OpenGL%E7%9A%84%E7%BB%98%E5%9B%BE%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E4%B8%8E%E6%A6%82%E5%BF%B5/</id>
    <published>2021-05-24T05:21:14.000Z</published>
    <updated>2022-09-02T06:49:21.359Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OpenGL的绘图基本流程与概念"><a href="#OpenGL的绘图基本流程与概念" class="headerlink" title="OpenGL的绘图基本流程与概念"></a>OpenGL的绘图基本流程与概念</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本博客仅记录本人的理解<br>全部内容来源于<a href="https://learnopengl-cn.readthedocs.io/zh/latest/">OpenGL</a>与<a href="http://colin1994.github.io/2017/11/11/OpenGLES-Lesson04/">GLSL</a>以及<a href="https://space.bilibili.com/211153830">傅老师OpenGL课程</a><br>如有问题,欢迎评论<br><span id="more"></span></p><h2 id="图形渲染管线"><a href="#图形渲染管线" class="headerlink" title="图形渲染管线"></a>图形渲染管线</h2><p><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/20210524115540.png" alt=""></p><p>图形渲染管线可以被划分为两个主要部分：</p><ul><li>第一部分把你的3D坐标转换为2D坐标</li><li>第二部分是把2D坐标转变为实际的有颜色的像素。<blockquote><p>分别对应第一排和第二排,实际学习中我们基本只用关注vertex shader和fragment shader,其他暂且不管</p></blockquote></li></ul><p>而图形渲染管线的输入便是顶点数据(vertex data),可以包含空间位置,颜色,uv等等信息</p><h2 id="GPU与CPU"><a href="#GPU与CPU" class="headerlink" title="GPU与CPU"></a>GPU与CPU</h2><p>首先我们需要对CPU与GPU有一定的认识,打个比方CPU就像是精英怪或者BOSS,GPU就像是小兵,GPU有着很高的性能,但对于大量的简单运算就显得CPU势单力薄,而GPU却能很好的解决这些问题,GPU有着庞大的基数,虽然每个GPU只能进行简单的运算和处理,但处理大量简单运算时速度就比孤军奋战的CPU快很多.所以在OpenGL中我们使用GPU来处理庞大的顶点数据,而这些运行在GPU的程序被称为shader也就是着色器.  </p><h2 id="VAO与VBO"><a href="#VAO与VBO" class="headerlink" title="VAO与VBO"></a>VAO与VBO</h2><p>所以我们来看这样一幅图<br><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/20210524122721.png" alt="">  </p><h3 id="VBO-顶点缓冲对象-Vertex-Buffer-Objects"><a href="#VBO-顶点缓冲对象-Vertex-Buffer-Objects" class="headerlink" title="VBO (顶点缓冲对象 [Vertex Buffer Objects] )"></a>VBO (顶点缓冲对象 [Vertex Buffer Objects] )</h3><p>CPU中的顶点数据通过一系列过程传输到GPU,为了节省CPU宝贵的内存,传输到GPU的数据会以数组的形式被立即保存在VBO中使用这些缓冲对象的好处是我们可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次。从CPU把数据发送到显卡相对较慢，所以只要可能我们都要尝试尽量一次性发送尽可能多的数据。当数据发送至显卡的内存中后，顶点着色器几乎能立即访问顶点，这是个非常快的过程。</p><h3 id="VAO-顶点数组对象-Vertex-Array-Object"><a href="#VAO-顶点数组对象-Vertex-Array-Object" class="headerlink" title="VAO (顶点数组对象 [Vertex Array Object] )"></a>VAO (顶点数组对象 [Vertex Array Object] )</h3><p>顶点着色器允许我们指定任何以顶点属性为形式的输入.我们传入VBO的数组有顶点位置有颜色有uv等各种信息,显然我们的顶点着色器是无法区分这些信息的.所以我们需要用VAO来让顶点着色器认识我们VBO数组中传入的信息都是些什么.我们的顶点缓冲数据会被解析为下面这样子：<br><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/20210524124443.png" alt=""><br>我们会指定每几个数据位一个顶点,如图中每3个数据为一个顶点的位置,如果有多个类型的数据,比如0,1,2为位置数据;3,4,5为颜色数据;6,7为uv数据,我们就需要指定8为一个步长,其中前三个为位置数据,偏移量为3的3个数据为颜色数据;偏移量为6的2个数据为uv数据.<br>将这些标注好后VAO就像下图一样<br><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/20210524125024.png" alt="">  </p><h3 id="EBO-索引缓冲对象-Element-Buffer-Object-也叫-Index-Buffer-Object，IBO"><a href="#EBO-索引缓冲对象-Element-Buffer-Object-也叫-Index-Buffer-Object，IBO" class="headerlink" title="EBO(索引缓冲对象 [ Element Buffer Object] 也叫 [Index Buffer Object，IBO] )"></a>EBO(索引缓冲对象 [ Element Buffer Object] 也叫 [Index Buffer Object，IBO] )</h3><p><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/20210524122721.png" alt=""><br>我们回到最开始的那张图,可以看出VAO除了Array buffer 还有一个Element Buffer.<br>在用glDrawArrays(GL_TRIANGLES)绘图时,如果我们只指定Array buffer,那么OpenGL就会以数组的顺序挨个逆时针以三角形的形式绘制这些顶点. 如果我们的图形较为复杂,这意味着会有很多重复的顶点出现,这会让我们的数组显得非常冗长,这时候我们可以定义一个EBO用来指定绘制顺序,如[0,1,2,1,0,2]就是以0,1,2的顺序绘制第一个三角形,再以1,0,2的顺序绘制第二个三角形</p><blockquote><p>注意:当目标是GL_ELEMENT_ARRAY_BUFFER的时候，VAO会储存glBindBuffer的函数调用。这也意味着它也会储存解绑调用，所以确保你没有在解绑VAO之前解绑索引数组缓冲，否则它就没有这个EBO配置了。  </p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/20210524125640.png" alt=""></p><h2 id="着色器-Shader"><a href="#着色器-Shader" class="headerlink" title="着色器 Shader"></a>着色器 Shader</h2><p>之前已经提到,着色器就是运行在GPU中的一个一个小程序.目前我们主要使用顶点着色器(vertex shader)和片段着色器(fragment shader).对于着色器,我们采用的是GLSL语言(OpenGL Shading Language)编写的程序,类似于C语言程序。<br>要使用着色器需要经历3个步骤:</p><ol><li>创建和编译shader object</li><li>创建shader program,链接多个shader object到program</li><li>在绘制场景时启用shader program<br>具体流程如下图所示:<br><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/20210524130018.png" alt=""><br>我们可以通过两个简单的顶点着色器代码来认识Shader</li></ol><ul><li>顶点着色器<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#version 330   // 指定GLSL版本3.3</span><br><span class="line"></span><br><span class="line">layout(location = 0) in vec3 position; // 顶点属性索引</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    gl_Position = vec4(position, 1.0); // 输出顶点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>片段着色器<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#version 330</span><br><span class="line"></span><br><span class="line">out vec4 color; // 输出片元颜色</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    color = vec4(0.8, 0.8, 0.0, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>着色器程序通过in 和 out也就是输入与输出连成一条线; 我们的顶点数据通过in传入顶点着色器然后输出顶点,然后顶点着色器的out通过片段着色器的in传入片段着色器并进行输出<blockquote><p>这里由于传入的数据没有颜色数据,所以在片段着色器的main中指定了一个颜色</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>由于qt和glfw语法略有不同, 且官网有具体代码, 这里只介绍流程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.加载库</span><br><span class="line">2.创建窗口</span><br><span class="line">3.传入数据</span><br><span class="line">4.定义VBO,并传入数据</span><br><span class="line">5.定义VAO,并链接VBO</span><br><span class="line">6.创建着色器程序</span><br><span class="line">7.创建引擎(渲染与其他操作)</span><br></pre></td></tr></table></figure></blockquote></li></ul><h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><p>OpenGL自身是一个巨大的状态机<strong>状态机(State Machine)</strong><br>一系列的变量描述OpenGL此刻应当如何运行。OpenGL的正在运行的状态通常被称为OpenGL上下文(Context)。<br>我们通常使用如下途径去更改OpenGL状态：设置选项，操作缓冲。<br>最后，我们使用当前OpenGL上下文来渲染。<br>假设当我们想告诉OpenGL去画线段而不是三角形的时候，我们通过改变一些上下文变量来改变OpenGL状态，从而告诉OpenGL如何去绘图。一旦我们改变了OpenGL的状态为绘制线段，下一个绘制命令就会画出线段而不是三角形。<br>所以OpenGL本质上是个大<strong>状态机</strong><br>下图是之前所提到的内容用状态机来表示的示例,我们可以通过glEnable来操作状态机里的各种状态<br><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/20210524151729.png" alt="">  </p><blockquote><p>VAO只能绑定一个VBO,所以如果有其他数据,需要解绑当前的VBO在bind所需VBO</p></blockquote><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>OpenGL库是用C语言写的，内核是一个C库。由于C的一些语言结构不易被翻译到其它的高级语言，因此OpenGL开发的时候引入了一些抽象层。“对象(Object)”就是其中一个。<br>在OpenGL中一个对象是指一些选项的集合，它代表OpenGL状态的一个子集。比如，我们可以用一个对象来代表绘图窗口的设置，之后我们就可以设置它的大小、支持的颜色位数等等。可以把对象看做一个C风格的结构体(Struct)：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct object_name &#123;</span><br><span class="line">    float  option1;</span><br><span class="line">    int    option2;</span><br><span class="line">    char[] name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>当我们使用一个对象时，通常看起来像如下一样（把OpenGL上下文看作一个大的结构体）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// OpenGL的状态</span><br><span class="line">struct OpenGL_Context &#123;</span><br><span class="line">    ...</span><br><span class="line">    object* object_Window_Target;</span><br><span class="line">    ...     </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 创建对象</span><br><span class="line">unsigned int objectId = 0;</span><br><span class="line">glGenObject(1, &amp;objectId);</span><br><span class="line">// 绑定对象至上下文</span><br><span class="line">glBindObject(GL_WINDOW_TARGET, objectId);</span><br><span class="line">// 设置当前绑定到 GL_WINDOW_TARGET 的对象的一些选项</span><br><span class="line">glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH, 800);</span><br><span class="line">glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, 600);</span><br><span class="line">// 将上下文对象设回默认,解绑对象</span><br><span class="line">glBindObject(GL_WINDOW_TARGET, 0);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;OpenGL的绘图基本流程与概念&quot;&gt;&lt;a href=&quot;#OpenGL的绘图基本流程与概念&quot; class=&quot;headerlink&quot; title=&quot;OpenGL的绘图基本流程与概念&quot;&gt;&lt;/a&gt;OpenGL的绘图基本流程与概念&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本博客仅记录本人的理解&lt;br&gt;全部内容来源于&lt;a href=&quot;https://learnopengl-cn.readthedocs.io/zh/latest/&quot;&gt;OpenGL&lt;/a&gt;与&lt;a href=&quot;http://colin1994.github.io/2017/11/11/OpenGLES-Lesson04/&quot;&gt;GLSL&lt;/a&gt;以及&lt;a href=&quot;https://space.bilibili.com/211153830&quot;&gt;傅老师OpenGL课程&lt;/a&gt;&lt;br&gt;如有问题,欢迎评论&lt;br&gt;</summary>
    
    
    
    <category term="计算机图形学" scheme="https://www.dante-game.com.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="学习" scheme="https://www.dante-game.com.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="记录" scheme="https://www.dante-game.com.cn/tags/%E8%AE%B0%E5%BD%95/"/>
    
    <category term="经验" scheme="https://www.dante-game.com.cn/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="计算机图形学" scheme="https://www.dante-game.com.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="OpenGL" scheme="https://www.dante-game.com.cn/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL GLFW, GLAD 在 Visual Studio 配置</title>
    <link href="https://www.dante-game.com.cn/2021/03/08/OpenGL%20%20GLFW,%20GLAD%20%E5%9C%A8%20Visual%20Studio%20%E9%85%8D%E7%BD%AE/"/>
    <id>https://www.dante-game.com.cn/2021/03/08/OpenGL%20%20GLFW,%20GLAD%20%E5%9C%A8%20Visual%20Studio%20%E9%85%8D%E7%BD%AE/</id>
    <published>2021-03-07T16:00:00.000Z</published>
    <updated>2022-09-02T06:49:21.357Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GLFW"><a href="#GLFW" class="headerlink" title="GLFW"></a>GLFW</h2><h3 id="下载GLFW"><a href="#下载GLFW" class="headerlink" title="下载GLFW"></a>下载GLFW</h3><p><a href="https://github.com/glfw/glfw/releases/download/3.3.3/glfw-3.3.3.zip">下载地址</a>  </p><p>下载好后解压解压</p><blockquote><p>github下载可能略慢,建议翻墙</p></blockquote><span id="more"></span><h3 id="下载CMake"><a href="#下载CMake" class="headerlink" title="下载CMake"></a>下载CMake</h3><p><a href="https://cmake.org/download/">下载地址</a><br>下载好后解压,打开’bin/cmake-gui.exe’<br>我们现在需要一个源代码目录(即之前下好的glfw)和一个存放编译结果的目标文件目录(新建一个build文件夹)  </p><blockquote><p>注意路径不要有中文<br><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/20210309013232.png" alt="cmake"><br>Configure(设置)按钮,选择VS2019 16,然后保存<br><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/20210309013317.png" alt="Configure"></p></blockquote><p>最后点击Generate(生成)按钮，生成的工程文件会在你的build文件夹中</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>在build文件夹里可以找到GLFW.sln文件，用VS打开,直接生成解决方案<br><code>glfw3.lib</code> 就会出现在 <code>src/Debug</code></p><p> <strong>glfw3.lib</strong> 放入路径 <code>C:\Program Files (x86) \ Microsoft Visual Studio \ (VS版本如2019) \ (VS版本如community/professional/Enterprise) \ VC \ Tools \ MSVC \ 14.28.29333 (版本号) \ lib \ x86或者x64 \</code></p><blockquote><p>取决于编译,建议使用x32</p></blockquote><p>将<code>glfw-3.3.3\include\GLFW</code> 整个文件夹放入路径 <code>C:\Program Files (x86) \ Microsoft Visual Studio \ (VS版本如2019) \ (VS版本如community/professional/Enterprise) \ VC \ Tools \ MSVC \ 14.28.29333 (版本号) \ include</code></p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>在VS<code>项目-&gt;工程属性-&gt;连接器-&gt;输入(input)-&gt;附加依赖项(第一项)</code>添加glfw3.lib<br><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/20210309032115.png" alt="lib"></p><h2 id="GLAD"><a href="#GLAD" class="headerlink" title="GLAD"></a>GLAD</h2><h3 id="配置GLAD"><a href="#配置GLAD" class="headerlink" title="配置GLAD"></a>配置GLAD</h3><p>打开<a href="http://glad.dav1d.de/">GLAD在线服务</a>设置如下后generate,下载提供的zip文件,解压<br><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/20210309014907.png" alt="GLAD"><br>把<code>glad\include</code>中的2个文件夹放入路径<code>C:\Program Files (x86) \ Microsoft Visual Studio \ (VS版本如2019) \ (VS版本如community/professional/Enterprise) \ VC \ Tools \ MSVC \ 14.28.29333 (版本号) \ include</code>  </p><p>把<strong>glad.c</strong>添加到工程文件中<br>最后你就能将以下的指令加到你的文件顶部了<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;glad/glad.h&gt; </span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;GLFW&quot;&gt;&lt;a href=&quot;#GLFW&quot; class=&quot;headerlink&quot; title=&quot;GLFW&quot;&gt;&lt;/a&gt;GLFW&lt;/h2&gt;&lt;h3 id=&quot;下载GLFW&quot;&gt;&lt;a href=&quot;#下载GLFW&quot; class=&quot;headerlink&quot; title=&quot;下载GLFW&quot;&gt;&lt;/a&gt;下载GLFW&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/glfw/glfw/releases/download/3.3.3/glfw-3.3.3.zip&quot;&gt;下载地址&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;下载好后解压解压&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;github下载可能略慢,建议翻墙&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="环境配置" scheme="https://www.dante-game.com.cn/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
    <category term="学习" scheme="https://www.dante-game.com.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="记录" scheme="https://www.dante-game.com.cn/tags/%E8%AE%B0%E5%BD%95/"/>
    
    <category term="经验" scheme="https://www.dante-game.com.cn/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="计算机图形学" scheme="https://www.dante-game.com.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch学习笔记5--分类Classification</title>
    <link href="https://www.dante-game.com.cn/2021/03/04/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05-%E5%88%86%E7%B1%BBClassification/"/>
    <id>https://www.dante-game.com.cn/2021/03/04/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05-%E5%88%86%E7%B1%BBClassification/</id>
    <published>2021-03-03T16:00:01.000Z</published>
    <updated>2022-09-02T06:49:21.362Z</updated>
    
    <content type="html"><![CDATA[<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>其实和回归那个神经网络没差,就是数据集变化了,神经网络的输入输出端变为2个参数  </p><p><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/%E5%88%86%E7%B1%BB.gif" alt="分类"></p><span id="more"></span><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import torch</span><br><span class="line">import torch.nn.functional as F</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">#数据集</span><br><span class="line">n_data = torch.ones(1000, 2)         # 数据的基本形态</span><br><span class="line">x0 = torch.normal(2*n_data, 1)      # 类型0 x data (tensor), shape=(100, 2)</span><br><span class="line">y0 = torch.zeros(1000)               # 类型0 y data (tensor), shape=(100, )</span><br><span class="line">x1 = torch.normal(-2*n_data, 1)     # 类型1 x data (tensor), shape=(100, 1)</span><br><span class="line">y1 = torch.ones(1000)                # 类型1 y data (tensor), shape=(100, )</span><br><span class="line"></span><br><span class="line"># 注意 x, y 数据的数据形式是一定要像下面一样 (torch.cat 是在合并数据)</span><br><span class="line">x = torch.cat((x0, x1), 0).type(torch.FloatTensor)  # FloatTensor = 32-bit floating</span><br><span class="line"></span><br><span class="line">y = torch.cat((y0, y1), ).type(torch.LongTensor)    # LongTensor = 64-bit integer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#网络</span><br><span class="line">class Net(torch.nn.Module):</span><br><span class="line">    def __init__(self,n_feature, n_hidden,n_output):</span><br><span class="line">        super(Net, self).__init__()</span><br><span class="line">        self.hidden = torch.nn.Linear(n_feature, n_hidden)#定义隐藏层结构</span><br><span class="line">        self.predict = torch.nn.Linear(n_hidden,n_output)#定义预测层结构,输出一个y</span><br><span class="line">    def forward(self,x): #正向传播输入一个x</span><br><span class="line">        x = torch.relu(self.hidden(x)) #正向传播x-&gt;relu过的x-&gt;output</span><br><span class="line">        x = self.predict(x)</span><br><span class="line">        return x</span><br><span class="line"></span><br><span class="line">net = Net(n_feature = 2,n_hidden=10,n_output = 2)  #创建神经网络</span><br><span class="line"></span><br><span class="line">print(net)#可以看出神经网络的结构</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 训练</span><br><span class="line">optimizer = torch.optim.SGD(net.parameters(),lr=0.02)#传入net的全部参数,学习率为0.2,越高越快,但也会出现梯度爆炸之类的问题</span><br><span class="line">#loss_func = torch.nn.MSELoss() MSE用于回归类型</span><br><span class="line">loss_func = torch.nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in range(500): #训练500次</span><br><span class="line">    out = net(x) #向神经网络传入 x , prediction 相当于神经网络正向传播完的y</span><br><span class="line"></span><br><span class="line">    loss = loss_func(out,y) #计算loss</span><br><span class="line"></span><br><span class="line">    print(loss)</span><br><span class="line">    time.sleep(0.5)#这里只是为了方便观察</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    optimizer.zero_grad()#梯度归零清空上一步的残余更新参数值</span><br><span class="line">    loss.backward()# 误差反向传播, 计算参数更新值</span><br><span class="line">    optimizer.step() # 将参数更新值施加到 net 的 parameters 上</span><br><span class="line"></span><br><span class="line">    if i % 2 == 0:</span><br><span class="line">        plt.cla()</span><br><span class="line">        # 过了一道 softmax 的激励函数后的最大概率才是预测值</span><br><span class="line">        prediction = torch.max(F.softmax(out,dim=1), 1)[1]</span><br><span class="line">        pred_y = prediction.data.numpy().squeeze()</span><br><span class="line">        target_y = y.data.numpy()</span><br><span class="line">        plt.scatter(x.data.numpy()[:, 0], x.data.numpy()[:, 1], c=pred_y, s=100, lw=0, cmap=&#x27;RdYlGn&#x27;)</span><br><span class="line">        accuracy = sum(pred_y == target_y)/2000.  # 预测中有多少和真实值一样</span><br><span class="line">        plt.text(1.5, -4, &#x27;Accuracy=%.2f&#x27; % accuracy, fontdict=&#123;&#x27;size&#x27;: 20, &#x27;color&#x27;:  &#x27;red&#x27;&#125;)</span><br><span class="line">        plt.pause(0.1)</span><br><span class="line">        plt.ion()</span><br><span class="line">        plt.show()</span><br><span class="line"></span><br><span class="line">plt.ioff()  # 停止画图</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;过程&quot;&gt;&lt;a href=&quot;#过程&quot; class=&quot;headerlink&quot; title=&quot;过程&quot;&gt;&lt;/a&gt;过程&lt;/h2&gt;&lt;p&gt;其实和回归那个神经网络没差,就是数据集变化了,神经网络的输入输出端变为2个参数  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Ao021/PicPub/%E5%88%86%E7%B1%BB.gif&quot; alt=&quot;分类&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://www.dante-game.com.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习" scheme="https://www.dante-game.com.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="记录" scheme="https://www.dante-game.com.cn/tags/%E8%AE%B0%E5%BD%95/"/>
    
    <category term="经验" scheme="https://www.dante-game.com.cn/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="Pytorch" scheme="https://www.dante-game.com.cn/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL(glut包)在Visual Studio配置</title>
    <link href="https://www.dante-game.com.cn/2021/03/04/OpenGL(glut%E5%8C%85)%E5%9C%A8Visual%20Studio%E9%85%8D%E7%BD%AE/"/>
    <id>https://www.dante-game.com.cn/2021/03/04/OpenGL(glut%E5%8C%85)%E5%9C%A8Visual%20Studio%E9%85%8D%E7%BD%AE/</id>
    <published>2021-03-03T16:00:00.000Z</published>
    <updated>2022-09-02T06:49:21.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OpenGL-glut包-在Visual-Studio配置"><a href="#OpenGL-glut包-在Visual-Studio配置" class="headerlink" title="OpenGL(glut包)在Visual Studio配置"></a>OpenGL(glut包)在Visual Studio配置</h1><h2 id="1-glut下载"><a href="#1-glut下载" class="headerlink" title="1.glut下载"></a>1.glut下载</h2><p> <a href="https://www.opengl.org/resources/libraries/glut/glutdlls37beta.zip">下载链接</a></p><h2 id="2-环境配置"><a href="#2-环境配置" class="headerlink" title="2.环境配置"></a>2.环境配置</h2><span id="more"></span><p>下载好会有如下文件<br><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/20210304215209.png" alt="下载文件"></p><h3 id="h-文件"><a href="#h-文件" class="headerlink" title=".h 文件"></a>.h 文件</h3><p> <strong>glut.h</strong> 放入路径 <code>C:\Program Files (x86) \ Microsoft Visual Studio \ (VS版本如2019) \ (VS版本如community/professional/Enterprise) \ VC \ Tools \ MSVC \ 14.28.29333 (版本号) \ include \ GL \</code>，GL是文件夹手动创建的。</p><h3 id="lib-文件"><a href="#lib-文件" class="headerlink" title=".lib 文件"></a>.lib 文件</h3><p> <strong>glut32.lib</strong> 放入路径 <code>C:\Program Files (x86) \ Microsoft Visual Studio \ (VS版本如2019) \ (VS版本如community/professional/Enterprise) \ VC \ Tools \ MSVC \ 14.28.29333 (版本号) \ lib \ x86 \</code>  </p><p><strong>glut32.lib</strong> 放入路径 <code>C:\Program Files (x86) \ Microsoft Visual Studio \ (VS版本如2019) \ (VS版本如community/professional/Enterprise) \ VC \ Tools \ MSVC \ 14.28.29333 (版本号) \ lib \ x64 \</code>  </p><h3 id="dll-文件"><a href="#dll-文件" class="headerlink" title=".dll 文件"></a>.dll 文件</h3><p><strong>glut.dll</strong> 和 <strong>glut32.dll</strong> 放入<code>C:\ Windows \ SysWOW64 \</code><br><strong>glut32.dll</strong> 放入 <code>C:\ Windows \ System32 \</code>  </p><blockquote><p><a href="https://blog.csdn.net/jjhfen00/article/details/50646834">参考blog</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;OpenGL-glut包-在Visual-Studio配置&quot;&gt;&lt;a href=&quot;#OpenGL-glut包-在Visual-Studio配置&quot; class=&quot;headerlink&quot; title=&quot;OpenGL(glut包)在Visual Studio配置&quot;&gt;&lt;/a&gt;OpenGL(glut包)在Visual Studio配置&lt;/h1&gt;&lt;h2 id=&quot;1-glut下载&quot;&gt;&lt;a href=&quot;#1-glut下载&quot; class=&quot;headerlink&quot; title=&quot;1.glut下载&quot;&gt;&lt;/a&gt;1.glut下载&lt;/h2&gt;&lt;p&gt; &lt;a href=&quot;https://www.opengl.org/resources/libraries/glut/glutdlls37beta.zip&quot;&gt;下载链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-环境配置&quot;&gt;&lt;a href=&quot;#2-环境配置&quot; class=&quot;headerlink&quot; title=&quot;2.环境配置&quot;&gt;&lt;/a&gt;2.环境配置&lt;/h2&gt;</summary>
    
    
    
    <category term="环境配置" scheme="https://www.dante-game.com.cn/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
    <category term="学习" scheme="https://www.dante-game.com.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="记录" scheme="https://www.dante-game.com.cn/tags/%E8%AE%B0%E5%BD%95/"/>
    
    <category term="经验" scheme="https://www.dante-game.com.cn/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="计算机图形学" scheme="https://www.dante-game.com.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>PicGo GitHub图床设置</title>
    <link href="https://www.dante-game.com.cn/2021/03/04/PicGo%20GitHub%E5%9B%BE%E5%BA%8A%E8%AE%BE%E7%BD%AE/"/>
    <id>https://www.dante-game.com.cn/2021/03/04/PicGo%20GitHub%E5%9B%BE%E5%BA%8A%E8%AE%BE%E7%BD%AE/</id>
    <published>2021-03-03T16:00:00.000Z</published>
    <updated>2022-09-02T06:49:21.359Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PicGo-GitHub图床设置"><a href="#PicGo-GitHub图床设置" class="headerlink" title="PicGo GitHub图床设置"></a>PicGo GitHub图床设置</h1><ol><li>创建一个仓库,用于存储图片</li><li>生成一个token,点击github右上角头像选项的Settings/Developer settings/Personal access tokens,点击generate new token生成token  </li></ol><span id="more"></span><p><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/20210304213307.png" alt="token"></p><ol><li>generate token后记得复制显示的token,只会出现这一次,如果忘记了需要regenerate</li><li>最后设置图床信息,仓库名为 用户名/仓库名形式,分支名为master,token为之前复制的一长串<br><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/20210304213638.png" alt="图床"></li><li>加速图床,由于GitHub国内访问速度很慢,在自定义域名加上<code>https://cdn.jsdelivr.net/gh/用户名/仓库名</code></li><li>最后保存就ok了</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;PicGo-GitHub图床设置&quot;&gt;&lt;a href=&quot;#PicGo-GitHub图床设置&quot; class=&quot;headerlink&quot; title=&quot;PicGo GitHub图床设置&quot;&gt;&lt;/a&gt;PicGo GitHub图床设置&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;创建一个仓库,用于存储图片&lt;/li&gt;
&lt;li&gt;生成一个token,点击github右上角头像选项的Settings/Developer settings/Personal access tokens,点击generate new token生成token  &lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="环境配置" scheme="https://www.dante-game.com.cn/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
    <category term="学习" scheme="https://www.dante-game.com.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="记录" scheme="https://www.dante-game.com.cn/tags/%E8%AE%B0%E5%BD%95/"/>
    
    <category term="经验" scheme="https://www.dante-game.com.cn/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch学习笔记3--激励函数</title>
    <link href="https://www.dante-game.com.cn/2021/03/04/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03-%E6%BF%80%E5%8A%B1%E5%87%BD%E6%95%B0/"/>
    <id>https://www.dante-game.com.cn/2021/03/04/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03-%E6%BF%80%E5%8A%B1%E5%87%BD%E6%95%B0/</id>
    <published>2021-03-03T16:00:00.000Z</published>
    <updated>2022-09-02T06:49:21.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="激励函数"><a href="#激励函数" class="headerlink" title="激励函数"></a>激励函数</h2><h3 id="什么是-Activation"><a href="#什么是-Activation" class="headerlink" title="什么是 Activation"></a>什么是 Activation</h3><p>激励函数是非线性函数<br>神经网络每一层出来都是线性的需要Activation掰弯来处理非线性问题  </p><p>常用的激励函数有</p><ul><li>relu</li><li>sigmoid</li><li>tanh</li><li>softplus</li></ul><span id="more"></span><h3 id="Torch中的激励函数"><a href="#Torch中的激励函数" class="headerlink" title="Torch中的激励函数"></a>Torch中的激励函数</h3><p><a href="https://mofanpy.com/tutorials/data-manipulation/plt/">python的可视化模块</a><br>以下是测试代码<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line">import torch.nn.functional as F</span><br><span class="line">from torch.autograd import variable #没啥用了好像</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">x = torch.linspace(-5,5,200)</span><br><span class="line">x_np = x.numpy()</span><br><span class="line"></span><br><span class="line">y_relu = torch.relu(x).numpy()</span><br><span class="line">y_sigmoid = torch.sigmoid(x).numpy()</span><br><span class="line">y_tanh = torch.tanh(x).numpy()</span><br><span class="line">y_softplus = F.softplus(x).numpy()</span><br><span class="line"></span><br><span class="line">plt.figure(1, figsize=(8, 6))</span><br><span class="line">plt.subplot(221)</span><br><span class="line">plt.plot(x_np, y_relu, c=&#x27;red&#x27;, label=&#x27;relu&#x27;)</span><br><span class="line">plt.ylim((-1, 5))</span><br><span class="line">plt.legend(loc=&#x27;best&#x27;)</span><br><span class="line"></span><br><span class="line">plt.subplot(222)</span><br><span class="line">plt.plot(x_np, y_sigmoid, c=&#x27;red&#x27;, label=&#x27;sigmoid&#x27;)</span><br><span class="line">plt.ylim((-0.2, 1.2))</span><br><span class="line">plt.legend(loc=&#x27;best&#x27;)</span><br><span class="line"></span><br><span class="line">plt.subplot(223)</span><br><span class="line">plt.plot(x_np, y_tanh, c=&#x27;red&#x27;, label=&#x27;tanh&#x27;)</span><br><span class="line">plt.ylim((-1.2, 1.2))</span><br><span class="line">plt.legend(loc=&#x27;best&#x27;)</span><br><span class="line"></span><br><span class="line">plt.subplot(224)</span><br><span class="line">plt.plot(x_np, y_softplus, c=&#x27;red&#x27;, label=&#x27;softplus&#x27;)</span><br><span class="line">plt.ylim((-0.2, 6))</span><br><span class="line">plt.legend(loc=&#x27;best&#x27;)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;激励函数&quot;&gt;&lt;a href=&quot;#激励函数&quot; class=&quot;headerlink&quot; title=&quot;激励函数&quot;&gt;&lt;/a&gt;激励函数&lt;/h2&gt;&lt;h3 id=&quot;什么是-Activation&quot;&gt;&lt;a href=&quot;#什么是-Activation&quot; class=&quot;headerlink&quot; title=&quot;什么是 Activation&quot;&gt;&lt;/a&gt;什么是 Activation&lt;/h3&gt;&lt;p&gt;激励函数是非线性函数&lt;br&gt;神经网络每一层出来都是线性的需要Activation掰弯来处理非线性问题  &lt;/p&gt;
&lt;p&gt;常用的激励函数有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;relu&lt;/li&gt;
&lt;li&gt;sigmoid&lt;/li&gt;
&lt;li&gt;tanh&lt;/li&gt;
&lt;li&gt;softplus&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://www.dante-game.com.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习" scheme="https://www.dante-game.com.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="记录" scheme="https://www.dante-game.com.cn/tags/%E8%AE%B0%E5%BD%95/"/>
    
    <category term="经验" scheme="https://www.dante-game.com.cn/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="Pytorch" scheme="https://www.dante-game.com.cn/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch学习笔记4--回归Regression</title>
    <link href="https://www.dante-game.com.cn/2021/03/04/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04-%E5%9B%9E%E5%BD%92Regression/"/>
    <id>https://www.dante-game.com.cn/2021/03/04/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04-%E5%9B%9E%E5%BD%92Regression/</id>
    <published>2021-03-03T16:00:00.000Z</published>
    <updated>2022-09-02T06:49:21.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>通过一个散点图建立一个简单神经网络  </p><p>步骤为  </p><ol><li>建立xy数据点集</li><li>定义神经网络结构,只有hidden和predict 2层</li><li>训练神经网络同时绘制图像<br><img src="https://cdn.jsdelivr.net/gh/Ao021/PicPub/%E5%9B%9E%E5%BD%92regression.gif" alt="训练过程"></li></ol><span id="more"></span><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line">import torch.nn.functional as F</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">#print(torch.linspace(-1,1,100))</span><br><span class="line">x = torch.unsqueeze(torch.linspace(-1,1,100),dim=1) #生成二维的-1到1的伪数据,输出是个列向量</span><br><span class="line">#print(&#x27;\n&#x27;,x)</span><br><span class="line"></span><br><span class="line">y = x.pow(2) + 0.2* torch.rand(x.size())   #把点应造成X^2的抖动函数</span><br><span class="line">plt.scatter(x.numpy(),y.numpy())</span><br><span class="line">plt.show()</span><br><span class="line">#输出图片</span><br><span class="line"></span><br><span class="line">class Net(torch.nn.Module):</span><br><span class="line">    def __init__(self,n_feature, n_hidden,n_output):</span><br><span class="line">        super(Net, self).__init__()</span><br><span class="line">        self.hidden = torch.nn.Linear(n_feature, n_hidden)#定义隐藏层结构</span><br><span class="line">        self.predict = torch.nn.Linear(n_hidden,n_output)#定义预测层结构,输出一个y</span><br><span class="line">    def forward(self,x): #正向传播输入一个x</span><br><span class="line">        x = torch.relu(self.hidden(x)) #正向传播x-&gt;relu过的x-&gt;output</span><br><span class="line">        x = self.predict(x)</span><br><span class="line">        return x</span><br><span class="line"></span><br><span class="line">net = Net(n_feature=1,n_hidden=10,n_output=1)  #创建神经网络</span><br><span class="line"></span><br><span class="line">print(net)#可以看出神经网络的结构</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 下面开始训练</span><br><span class="line">optimizer = torch.optim.SGD(net.parameters(),lr=0.2)#传入net的全部参数,学习率为0.2,越高越快,但也会出现梯度爆炸之类的问题</span><br><span class="line">loss_func = torch.nn.MSELoss()</span><br><span class="line"></span><br><span class="line">for i in range(500): #训练500次</span><br><span class="line">    prediction = net(x) #向神经网络传入 x , prediction 相当于神经网络正向传播完的y</span><br><span class="line"></span><br><span class="line">    loss = loss_func(prediction,y) #计算loss</span><br><span class="line"></span><br><span class="line">    optimizer.zero_grad()#梯度归零清空上一步的残余更新参数值</span><br><span class="line">    loss.backward()# 误差反向传播, 计算参数更新值</span><br><span class="line">    optimizer.step() # 将参数更新值施加到 net 的 parameters 上</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#绘图</span><br><span class="line">    if i % 5 == 0:</span><br><span class="line">        # plot and show learning process</span><br><span class="line">        plt.cla()</span><br><span class="line">        plt.scatter(x.data.numpy(), y.data.numpy())</span><br><span class="line">        plt.plot(x.data.numpy(), prediction.data.numpy(), &#x27;r-&#x27;, lw=5)</span><br><span class="line">        plt.text(0.5, 0, &#x27;Loss=%.4f&#x27; % loss.data.numpy(), fontdict=&#123;&#x27;size&#x27;: 20, &#x27;color&#x27;:  &#x27;red&#x27;&#125;)</span><br><span class="line">        plt.pause(0.1)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;过程&quot;&gt;&lt;a href=&quot;#过程&quot; class=&quot;headerlink&quot; title=&quot;过程&quot;&gt;&lt;/a&gt;过程&lt;/h2&gt;&lt;p&gt;通过一个散点图建立一个简单神经网络  &lt;/p&gt;
&lt;p&gt;步骤为  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;建立xy数据点集&lt;/li&gt;
&lt;li&gt;定义神经网络结构,只有hidden和predict 2层&lt;/li&gt;
&lt;li&gt;训练神经网络同时绘制图像&lt;br&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Ao021/PicPub/%E5%9B%9E%E5%BD%92regression.gif&quot; alt=&quot;训练过程&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://www.dante-game.com.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习" scheme="https://www.dante-game.com.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="记录" scheme="https://www.dante-game.com.cn/tags/%E8%AE%B0%E5%BD%95/"/>
    
    <category term="经验" scheme="https://www.dante-game.com.cn/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="Pytorch" scheme="https://www.dante-game.com.cn/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch学习笔记-pip安装python模块使用国内镜像</title>
    <link href="https://www.dante-game.com.cn/2021/03/02/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-pip%E5%AE%89%E8%A3%85python%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F/"/>
    <id>https://www.dante-game.com.cn/2021/03/02/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-pip%E5%AE%89%E8%A3%85python%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F/</id>
    <published>2021-03-01T16:00:00.000Z</published>
    <updated>2022-09-02T06:49:21.360Z</updated>
    
    <content type="html"><![CDATA[<h2 id="镜像源"><a href="#镜像源" class="headerlink" title="镜像源"></a>镜像源</h2><p>由于<code>pip install</code> 都是从海外源下载,正常的 install 很慢<br>使用国内的镜像源会大幅度提升 install 速度</p><h3 id="以下的国内的一些镜像源"><a href="#以下的国内的一些镜像源" class="headerlink" title="以下的国内的一些镜像源"></a>以下的国内的一些镜像源</h3><span id="more"></span><p>镜像源：<br>豆瓣：<a href="https://pypi.douban.com/simple/">https://pypi.douban.com/simple/</a><br>清华：<a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.douban.com/simple/</a><br>阿里：<a href="https://mirrors.aliyun.com/pypi/simple/">https://pypi.douban.com/simple/</a><br>中国科技大学 ：<a href="https://pypi.mirrors.ustc.edu.cn/simple/">https://pypi.douban.com/simple/</a></p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ul><li>方法1<br><code>pip install 模块名 -i 以上镜像源网址</code></li><li>方法2<br>在user目录中创建一个pip目录，如：C:\Users\用户名\pip，新建文件pip.ini，内容如下 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  [global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>url内容可以任意更换为以上源</li></ul><blockquote><p><a href="https://www.jianshu.com/p/2e33b1ed27b7">参考blog</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;镜像源&quot;&gt;&lt;a href=&quot;#镜像源&quot; class=&quot;headerlink&quot; title=&quot;镜像源&quot;&gt;&lt;/a&gt;镜像源&lt;/h2&gt;&lt;p&gt;由于&lt;code&gt;pip install&lt;/code&gt; 都是从海外源下载,正常的 install 很慢&lt;br&gt;使用国内的镜像源会大幅度提升 install 速度&lt;/p&gt;
&lt;h3 id=&quot;以下的国内的一些镜像源&quot;&gt;&lt;a href=&quot;#以下的国内的一些镜像源&quot; class=&quot;headerlink&quot; title=&quot;以下的国内的一些镜像源&quot;&gt;&lt;/a&gt;以下的国内的一些镜像源&lt;/h3&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://www.dante-game.com.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习" scheme="https://www.dante-game.com.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="记录" scheme="https://www.dante-game.com.cn/tags/%E8%AE%B0%E5%BD%95/"/>
    
    <category term="经验" scheme="https://www.dante-game.com.cn/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="Pytorch" scheme="https://www.dante-game.com.cn/tags/Pytorch/"/>
    
    <category term="python" scheme="https://www.dante-game.com.cn/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch学习笔记--自动求导机制</title>
    <link href="https://www.dante-game.com.cn/2021/02/19/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-Autograd%20%E8%87%AA%E5%8A%A8%E6%B1%82%E5%AF%BC%E6%9C%BA%E5%88%B6/"/>
    <id>https://www.dante-game.com.cn/2021/02/19/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-Autograd%20%E8%87%AA%E5%8A%A8%E6%B1%82%E5%AF%BC%E6%9C%BA%E5%88%B6/</id>
    <published>2021-02-18T16:00:00.000Z</published>
    <updated>2022-09-02T06:49:21.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Autograd-自动求导机制"><a href="#Autograd-自动求导机制" class="headerlink" title="Autograd: 自动求导机制"></a>Autograd: 自动求导机制</h2><p>PyTorch 中所有神经网络的核心是 autograd 包。 我们先简单介绍一下这个包，然后训练第一个简单的神经网络。</p><p>autograd包为张量上的所有操作提供了自动求导。 它是一个在运行时定义的框架，这意味着反向传播是根据你的代码来确定如何运行，并且每次迭代可以是不同的。</p><span id="more"></span><p>示例</p><p>张量（Tensor）<br>torch.Tensor是这个包的核心类。如果设置 .requires_grad 为 True，那么将会追踪所有对于该张量的操作。 当完成计算后通过调用 .backward()，自动计算所有的梯度， 这个张量的所有梯度将会自动积累到 .grad 属性。</p><p>要阻止张量跟踪历史记录，可以调用.detach()方法将其与计算历史记录分离，并禁止跟踪它将来的计算记录。</p><p>为了防止跟踪历史记录（和使用内存），可以将代码块包装在with torch.no_grad()：中。 在评估模型时特别有用，因为模型可能具有requires_grad = True的可训练参数，但是我们不需要梯度计算。</p><p>在自动梯度计算中还有另外一个重要的类Function.</p><p>Tensor and Function are interconnected and build up an acyclic graph, that encodes a complete history of computation. Each tensor has a .grad_fn attribute that references a Function that has created the Tensor (except for Tensors created by the user - their grad_fn is None).</p><p>Tensor 和 Function互相连接并生成一个非循环图，它表示和存储了完整的计算历史。 每个张量都有一个.grad_fn属性，这个属性引用了一个创建了Tensor的Function（除非这个张量是用户手动创建的，即，这个张量的 grad_fn 是 None）。</p><p>如果需要计算导数，你可以在Tensor上调用.backward()。 如果Tensor是一个标量（即它包含一个元素数据）则不需要为backward()指定任何参数， 但是如果它有更多的元素，你需要指定一个gradient 参数来匹配张量的形状。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Autograd-自动求导机制&quot;&gt;&lt;a href=&quot;#Autograd-自动求导机制&quot; class=&quot;headerlink&quot; title=&quot;Autograd: 自动求导机制&quot;&gt;&lt;/a&gt;Autograd: 自动求导机制&lt;/h2&gt;&lt;p&gt;PyTorch 中所有神经网络的核心是 autograd 包。 我们先简单介绍一下这个包，然后训练第一个简单的神经网络。&lt;/p&gt;
&lt;p&gt;autograd包为张量上的所有操作提供了自动求导。 它是一个在运行时定义的框架，这意味着反向传播是根据你的代码来确定如何运行，并且每次迭代可以是不同的。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://www.dante-game.com.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习" scheme="https://www.dante-game.com.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="记录" scheme="https://www.dante-game.com.cn/tags/%E8%AE%B0%E5%BD%95/"/>
    
    <category term="经验" scheme="https://www.dante-game.com.cn/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="Pytorch" scheme="https://www.dante-game.com.cn/tags/Pytorch/"/>
    
  </entry>
  
</feed>
